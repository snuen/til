# June 2025 TIL (Today I Learned)

This file contains things I learned during June 2025.

---

## 2025-06-05: transformが使われている要素内でpositionする時の落とし穴と対策

CSSの`transform`プロパティが適用された要素は、**新しいコンテインニングブロック（containing block）**や**スタッキングコンテキスト**を作成する。

そのため、`position: absolute`や`position: fixed`で子要素を配置する際、意図しない位置になることがある。

### 具体例

```css
.container {
  transform: translateX(100px);
  position: relative;
}

.child {
  position: absolute;
  top: 0;
  left: 0;
}
```

この場合、`.child`は`.container`の**変形後の領域の左上**を基準に配置される。

`.container`に`transform`がなければ、通常のレイアウトフローに従うが、`transform`があると「変形後のボックス」が基準点となる。

### よくあるトラブル

- **意図しないズレ**
  例えば、モーダルやツールチップなどを絶対配置したい場合、親要素に`transform`があると、思った場所に表示されないことがある。
- **position: fixedの挙動変化**
  通常`fixed`はビューポート基準だが、`transform`がかかった親要素内では、その親要素が基準になる。

### なぜこうなる？

- `transform`が適用されると、その要素は**containing block**（絶対配置や固定配置の基準）になる。
- これは仕様であり、`filter`や`perspective`など一部のプロパティでも同様。

### 対策・ベストプラクティス

- **絶対配置したい要素の親にtransformをかけない**
  レイアウト用の親要素と、transformを使う要素を分離する。
- **どうしてもtransformが必要な場合は、absolute/fixedの基準を意識して設計する**
- **position: relativeを併用して意図的に基準を作る**
  必要に応じて、親要素の構造を見直す。

### 参考リンク・引用

- [transform - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/CSS/transform)
  > If the property has a value different from none, a stacking context will be created. In that case, the element will act as a containing block for any position: fixed; or position: absolute; elements that it contains.
- [CSS: Containing block - MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block)
- [It’s always the stacking context. ](https://css-tricks.com/its-always-the-stacking-context/)

---

## 2025-06-04: Next.jsアプリのホスティング選択肢を徹底比較

Next.jsアプリケーションをホストする方法は、プロジェクトの規模、要件、運用体制により最適解が異なる。ここでは主要なホスティング方法の特徴とメリット・デメリットを整理し、選定のポイントを明確にする。

### 1. マネージドホスティング（PaaS）

#### Vercel（Next.js公式）

Next.jsと最も相性がよい公式PaaS。最新機能（Edge Functions、ISR、Middleware等）への対応が早い。

- **メリット**

  - Next.jsとの完全な互換性。
  - Git連携で簡単にデプロイ可能。
  - 自動スケーリング、CDN、画像最適化が標準搭載。
  - Preview Deploymentsや環境変数管理が容易。

- **デメリット**

  - 無料プランのビルド時間や帯域に制限が厳しい。
  - 商用や規模が大きい場合、有料プランが必須。
  - 独自のインフラ要件への対応は難しい。

#### Netlify（Jamstack特化）

静的サイトやサーバーレスAPIに特化したサービス。

- **メリット**

  - 静的エクスポート、サーバーレスFunctionsが簡単。
  - GitHub連携やCI/CDが容易。

- **デメリット**

  - Next.jsのSSRや動的ルーティングのサポートは限定的。
  - Next.jsのフル機能活用には注意が必要。

#### Cloudflare Pages

Cloudflareが提供するPaaS。Edgeでの動的コンテンツ提供に強み。

- **メリット**

  - 世界中のエッジネットワークを利用した高速な配信。
  - Git統合による簡単なデプロイ。
  - 無料プランが比較的充実している。
  - Workersとの組み合わせで動的コンテンツにも対応。

- **デメリット**

  - Next.jsの特定機能（ISR、Middleware等）の対応状況に注意が必要。
  - Vercelほど完全な機能互換性はない場合がある。

#### その他（AWS Amplify、Azure Static Web Appsなど）

- 大手クラウド提供のPaaSサービスだが、Next.js対応状況に差があるため要確認。

### 2. セルフホスティング（VPS・自前サーバー）

#### 静的エクスポート（`next export`）

Next.jsを静的サイトとしてビルドし、S3＋CloudFrontなどのCDNで配信。

- **メリット**

  - 高速、高可用性で低コスト。
  - サーバーレス運用が可能。

- **デメリット**

  - API Routes、SSR、ISRなど動的機能が使えない。
  - 更新のたびに再ビルドと再デプロイが必要。

#### Node.jsサーバー（VPS上）

VPSで直接Node.jsサーバーとしてNext.jsを運用。

- **メリット**

  - Next.js全機能（SSR/ISR/API Routes）が利用可能。
  - インフラやミドルウェアを自由にカスタマイズ。

- **デメリット**

  - サーバー運用の管理・セキュリティ・スケーリングの責任が発生。
  - インフラ運用の専門知識や監視体制が必要。

#### Dockerコンテナ運用

Dockerを使ってNext.jsアプリをコンテナ化し、VPSやクラウド環境で運用。

- **メリット**

  - 環境差異を吸収し、移植性が高い。
  - CI/CDやサービス連携が容易。

- **デメリット**

  - Dockerおよびオーケストレーション（Compose、Kubernetes）の知識が必要。
  - 構築や運用はやや複雑。

#### セルフホスト型PaaS（Coolify、Dokployなど）

VPSに独自のPaaS環境を構築。

- **メリット**

  - Vercel/Netlifyのようなユーザー体験をセルフホストで再現可能。
  - 複数プロジェクトの一元管理が容易。

- **デメリット**

  - PaaS自体のメンテナンスが必要。
  - 商用サービスより安定性や機能性が劣ることがある。

### 3. 選定のポイント・実践Tips

- **小規模・個人開発**：VercelやNetlifyが最適。無料枠内で簡単に運用可能。
- **商用・中〜大規模プロジェクト**：有料PaaSまたはセルフホスティング（Docker/VPS）を検討。SLA、セキュリティ、運用体制を考慮。
- **静的サイト中心**：静的エクスポート＋CDNが高速かつシンプル。
- **SSRや動的機能重視**：Node.jsサーバーまたはDockerコンテナでの運用が必須。
- **コスト重視**：セルフホスティングは初期コストを抑えられるが、運用負担がある。
- **学習・検証用途**：まずVercelで始め、ニーズに応じて他の方法に切り替えるとスムーズ。

### 4. 注意点

- Next.jsのバージョンや機能によってホスティングの対応状況が異なる場合があるため、事前に確認が必要。
- 商用利用ではSLAやセキュリティ、バックアップ体制を必ず確認。
- 運用を効率化するために、CI/CDや監視システムの整備を推奨。

### 参考リンク

- [How To Host Next.js In 2025 (VPS, Self-Hosting, Managed)](https://youtu.be/ze1zrmoElrs)
- [How to deploy your Next.js application](https://nextjs.org/docs/app/getting-started/deploying)

---

## 2025-06-03: TypeScriptの型操作テクニック集

TypeScriptで型を柔軟に扱うための実践的なテクニックや知見をまとめる。

API設計やライブラリ開発、アプリケーション実装時に役立つ型の使い分けや、ユーティリティ型の活用方法などを整理。

### Key OptionalとValue Optionalの違い

全てKey optionalのケース

```ts
const doThing = (ctx: { traceId?: string }) => {};

const doAnotherThing = (ctx: { traceId?: string }) => {};

export const mainFunction = (ctx: { traceId?: string }) => {
  doThing({}); // traceIdは省略可能
  doAnotherThing({}); // traceIdは省略可能
};

mainFunction({}); // traceIdは省略可能
```

一部Value optionalのケース

```ts
const doThing = (ctx: { traceId: string | undefined }) => {};

const doAnotherThing = (ctx: { traceId: string | undefined }) => {};

export const mainFunction = (ctx: { traceId?: string }) => {
  doThing({}); // traceIdは省略できない
  doAnotherThing({}); // traceIdは省略できない
};

mainFunction({}); // traceIdは省略可能
```

全てValue optionalのケース

```ts
const doThing = (ctx: { traceId: string | undefined }) => {};

const doAnotherThing = (ctx: { traceId: string | undefined }) => {};

export const mainFunction = (ctx: { traceId: string | undefined }) => {
  doThing({}); // traceIdは省略できない
  doAnotherThing({}); // traceIdは省略できない
};

mainFunction({}); // traceIdは省略できない
```

#### 使い分けのポイント

- 表出するAPIをきれいに提供するために、Key optionalにする
  - ライブラリコードで提供するならこっちが有効かも
- 渡すプロパティを必ず保証するために、Value optionalにする
  - アプリケーションコードではこっちが有効かも

### Pick/Omit vs Extract/Exclude

Pick/Omit

```ts
type Album = {
  title: string;
  artist: string;
  releaseYear?: number;
  genre?: {
    parentGenre?: string;
    subGenre?: string;
  };
};

type AlbumData1 = Pick<Album, 'title' | 'artist'>; // titleとartistのみを抽出

type AlbumData2 = Omit<Album, 'releaseYear' | 'genre'>; // releaseYearとgenreを除外
```

Extract/Exclude

```ts
type AlbumState =
  | { type: 'released'; releaseDate: string }
  | { type: 'recording'; studio: string }
  | { type; mixing; engineer: string };

type NotReleased = Exclude<AlbumState, { type: 'released' }>; // 'released'以外の状態を抽出
```

```ts
type Example = 'a' | 'b' | 1 | 2 | 'c';

type Strings = Extract<Example, string>; // string型の部分のみを抽出

type Numbers = Extract<Example, number>; // number型の部分のみを抽出
```

### Prettify

```ts
type ComplexType = {
  a: string;
  b: number;
} & {
  c: boolean;
} & {
  d: string[];
};

type ShowMe = ComplexType; // これをPrettifyしたい

type Prettify<T> = {
  [K in keyof T]: T[K];
} & {};

type PrettyShowMe = Prettify<ShowMe>; // これでPrettifyされる
```

#### 使い道

ライブラリコードで、ユーザー側が見やすく型を提供したいのなら特に有効かも

### Loose Autocomplete

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7';

const model1: ModelNames = 'gpt-4o'; // Autocompleteが効く
```

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7' | string;

const model1: ModelNames = ''; // Autocompleteは効かない
```

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7' | (string & {});

const model1: ModelNames = 'some-arbitrary-model'; // Autocompleteが効く
```

### Mapped Types

```ts
type User = {
  id: string;
  name: string;
  age: number;
};

// 全てのプロパティをそのままコピーする
type UserTransformed = {
  [K in keyof User]: User[K];
};

// 全てのプロパティを関数形式に変換する
type UserTransformedWithFunctions = {
  [K in keyof User as `get${Capitalize<K>}`]: () => User[K];
};
```

### 参考リンク

- [6 TypeScript tips to turn you into a WIZARD](https://youtu.be/lraHlXpuhKs)

---

## 2025-06-02: RemixがReactやめてPreactに移行するらしい

### 背景を知る

#### React Routerとの統合による役割の変化

Remix v2はReact Routerの薄いラッパーに過ぎなくなっており、その結果、両プロジェクト間に人工的な分離が生じていた。

この状況を解消するため、RemixのバンドラーやサーバーランタイムのコードをReact Router v7に統合し、Remixの主要な機能をReact
Router v7の「フレームワークモード」に組み込んだ。

これにより、Remix v1およびv2、さらには以前のReact
Routerバージョンで構築されたアプリケーションに対して、長期的なサポートを提供する安定したプラットフォームが実現した。

#### 新たな方向性とPreactの採用

React Routerが成熟し、堅牢なプラットフォームとなったことで、Remixは新たな方向性を模索する自由を得た。

その結果、Remix
v3では、より軽量でウェブ標準に近いアプローチを採用するため、ReactではなくPreact（正確にはそのフォーク）を選択した。

Preactは、Reactと同様のAPIを提供しつつ、サイズが小さく、パフォーマンスに優れている。

また、Preactは標準のブラウザイベントを使用し、DOM仕様により忠実であるため、ウェブプラットフォームとの親和性が高いとされている。

#### 現代のウェブ開発に対する再評価

Reactのエコシステムは強力である一方で、複雑さや抽象化の過剰さが問題視されている。

Josh
Collinsworth氏は、Reactが提供する抽象化が、開発者にとって本来のウェブのシンプルさを忘れさせてしまっていると指摘している。

例えば、Reactのフックや状態管理は強力だが、それが必ずしも最適解ではなく、他のアプローチ（例えば、PreactのSignalsなど）も検討に値すると述べている。

#### Remix v3の設計原則

Remix v3は、以下のような設計原則に基づいて構築されている。

- モデルファースト開発：AIと人間の両方が理解しやすいコードを目指す。
- ウェブAPIの活用：ブラウザの標準機能を最大限に活用し、不要な抽象化を避ける。
- ランタイム重視：ビルドツールやコンパイラに依存せず、実行時のシンプルさを追求する。
- 依存関係の最小化：外部ライブラリへの依存を減らし、自律的な開発を可能にする。

これらの原則は、Reactのような大規模なエコシステムから脱却し、より軽量で柔軟な開発体験を提供することを目的としている。

### まとめ

RemixがReactからPreactへと移行した背景には、技術的な最適化だけでなく、ウェブ開発の本質への回帰という哲学的な意図がある。

React
Routerとの統合によりRemixの役割が変化し、新たな方向性として、より軽量でウェブ標準に近いPreactを採用することで、開発者にとってシンプルで効率的なフレームワークを提供しようとしている。

### 参考リンク

- [Wake up, Remix!](https://remix.run/blog/wake-up-remix)
- [Things you forgot (or never knew) because of React](https://joshcollinsworth.com/blog/antiquated-react)
- [Differences to React](https://preactjs.com/guide/v10/differences-to-react)

---

## 2025-06-01: CSSのoklch指定について

CSSで色を指定する際に、`oklch`という新しい色空間が使えるようになってきた。

### oklchとは？

- oklchは「明度（L）」「彩度（C）」「色相（H）」で色を指定できる色空間。
- 直感的に「明るさ」「鮮やかさ」「色味」を個別にコントロールできる。
- sRGBやhslよりも人間の知覚に近い色変化が得られる。

### 例

```css
.button {
  background: oklch(80% 0.15 200);
  color: oklch(30% 0.02 40);
}
```

- 明度（L）を変えるだけで、自然な明るさ調整ができる。
- 彩度（C）を0に近づけるとグレースケールに。

### メリット

- アクセシビリティ対応（コントラスト調整）がしやすい
- ダークモード/ライトモードの色設計が直感的
- デザイントークンやカラーパレット生成に最適

### 注意点

- 2025年6月時点で、主要ブラウザの最新バージョンでほぼサポートされているが、古い環境では未対応の場合あり
- Figmaやデザインツール側の対応状況も要確認

### 参考リンク

- [OKLCH Color Picker](https://oklch.com/)
- [CSS Color 4: oklch()](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklch)

---

<!-- Template for new entries -->
<!--
## 2025-06-XX: [Topic Title]

[Description of what you learned today]

### Example/Code (if applicable)

```txt
# Code example here
```

### References

- [Reference link 1](https://example.com)
- [Reference link 2](https://example.com)
-->
