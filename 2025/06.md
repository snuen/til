# June 2025 TIL (Today I Learned)

This file contains things I learned during June 2025.

---

## 2025-06-09: VS CodeでコミットメッセージをAI自動生成する方法まとめ

JetBrains IDE以外で、**VS CodeでコミットメッセージをAI生成したい**場合の選択肢・使い分け・注意点を整理。

### 1. GitHub Copilotによるコミットメッセージ生成

- **使い方**: 変更をステージ後、Source Controlビューのコミットメッセージ欄右上の ✨（sparkles）ボタンをクリック。
- **仕組み**: ステージ済みの差分（diff）のみをOpenAIモデルに送信し、Conventional Commits形式で要約・提案される。
- **生成例**:

  ```
  feat: add user authentication logic

  - implement login and logout features
  - add JWT token handling
  - update user model and tests
  ```

- **セキュリティ**: 差分のみ送信されるため、未ステージのファイルや他の情報は送信されない。
- **導入方法**: Copilot Chat拡張（v0.22以降）をインストールすれば利用可能。

**メリット**

- 導入が非常に簡単（拡張機能を入れるだけ）
- 差分のみ送信で情報漏洩リスクが低い
- Conventional Commits形式で統一感のあるメッセージ
- 1クリックで完結、学習コストほぼゼロ

**デメリット**

- GitHub Copilotの有料サブスクリプションが必要
- オフラインでは利用不可
- 英語メインの提案が多い（日本語化は手動修正が必要な場合あり）

### 2. GitLens (GitKraken AI)によるコミットメッセージ生成

- **使い方**: 変更をステージ後、Source Controlパネル上部の **Generate Commit Message (AI)**
  ボタン、またはコマンドパレットから`GitLens: Generate Commit Message with AI`を実行。
- **仕組み**: ステージ済み差分をAI（GitKrakenのクラウドサービス）に送信し、先頭行にサマリー、2行目以降に詳細という2段構成で生成される。編集して確定可能。
- **生成例**:

  ```
  fix: resolve login redirect bug

  - correct redirect logic after login
  - add test for edge case
  ```

- **セキュリティ**: 差分のみ送信。GitKrakenアカウントでのサインインが必要。
- **導入方法**: GitLens拡張をインストールし、AI機能はPro以上のサブスクリプションで利用可能。

**メリット**

- GitLens拡張のみで導入できる
- 差分を見ながらワンクリック生成、編集も容易
- Conventional Commits形式での出力

**デメリット**

- GitKrakenアカウント＋有料サブスクリプションが必要
- オフライン利用不可
- 英語メインの提案が多い

### 3. その他の選択肢・補足

- **ローカルLLMやCLIツール**: セキュリティ重視なら、ローカルで動作するコミットメッセージ生成ツール（例: aicommits,
  commitizen + LLM連携）も検討可能。ただしセットアップや精度は要検証。
- **どちらを選ぶべきか**:
  - Copilotは既に契約している場合や、よりシームレスな体験を求める場合に最適。
  - GitLensは既存のGitLensユーザーや、詳細な履歴管理・AI補助を求める場合に向く。
- **注意点**: どちらもインターネット接続必須。AI生成内容は必ず確認・編集すること。

### 参考リンク

- [GitHub Copilot — Commit messages](https://github.blog/developer-skills/github/how-to-use-github-copilot-in-your-ide-tips-tricks-and-best-practices/)
- [GitLens AI — Generate Commit Message](https://help.gitkraken.com/gitlens/gl-gk-ai/)
- [aicommits (CLI)](https://github.com/Nutlope/aicommits)
- [commitizen](https://commitizen-tools.github.io/commitizen/)

---

## 2025-06-08: Denoのテスト徹底ガイド

Denoはテスト機能が標準で組み込まれており、追加ライブラリなしでユニットテスト・統合テスト・ドキュメントテストまで幅広く対応できます。ここではDenoのテストの特徴、書き方、実践的な活用法、注意点を体系的にまとめます。

### 1. Denoのテストは“標準装備”

- `deno test`コマンドと`Deno.test()`APIが最初から利用可能。
- 標準ライブラリ（`@std/assert`など）を使えば、すぐにテストを始められる。
- 追加のテストフレームワークや設定は不要。

**基本例:**

```ts
import { assertEquals } from 'jsr:@std/assert';

Deno.test('足し算', () => {
  assertEquals(1 + 2, 3);
});
```

- テストファイルや関数は自動検出され、`deno test`で一括実行。
- テストごとに`--allow-read`などの権限フラグを個別に付与可能。

### 2. 多彩なテスト記述スタイル

- **サブステップ分割:** `t.step("setup", async () => {...})`で1テストを細かく分割し、可読性や粒度を調整できる。
- **assert/expectの選択:**
  `assertEquals`などのアサーションに加え、`expect(x).toBe(y)`のようなJest風シンタックスも利用可能（`@std/expect`）。
- **BDDスタイル:** `describe`/`it`/`beforeEach`など、Mocha/Jest風の記法も標準ライブラリでサポート。

**BDD例:**

```ts
import { describe, it, beforeEach } from 'jsr:@std/testing/bdd';
import { expect } from 'jsr:@std/expect';

describe('Calculator', () => {
  let calc: Calculator;
  beforeEach(() => (calc = new Calculator()));

  it('adds numbers', () => {
    calc.add(2);
    expect(calc.result).toBe(2);
  });
});
```

- **ドキュメントテスト:** `deno test --doc example.ts`でMarkdownやJSDocのコードブロックも自動実行。

### 3. テスト実行オプション

- **並列実行:** `--parallel`で高速化。
- **フィルタ:** `--filter "user"`や`--filter /regex/`で特定テストのみ実行。
- **fail-fast:** `--fail-fast`で1件失敗時に即終了。
- **レポーター:** `--reporter=pretty|dot|junit`や`--junit-path`で出力形式を選択。
- **カバレッジ:** `deno test --coverage=cov`→`deno coverage cov --lcov`でカバレッジ計測。

### 4. モッキングとテストダブル

- 標準ライブラリ`@std/testing/mock`でspy・stub・FakeTimeなどが簡単に使える。

**spyの例:**

```ts
import { spy, assertSpyCalls } from 'jsr:@std/testing/mock';

const log = spy(console, 'log');
console.log('hello');
assertSpyCalls(log, 1);
log.restore();
```

- **spy:** 呼び出し回数や引数を検証（実装はそのまま）。
- **stub:** 元実装を差し替えて戻り値を制御。
- **FakeTime:** 時刻依存のテストを疑似的に進める。

### 5. スナップショットテスト

- `assertSnapshot(t, value, options)`で値やDOMツリーのスナップショットを取得・検証。
- `-u`/`--update`でスナップショット自動更新、`dir`や`path`で保存先指定も可能。

### 6. Webアプリ・DOMテスト

- DenoはブラウザDOMが使えないが、`deno-dom`や`jsdom`と組み合わせればDOM操作やイベント、fetchの検証も可能。
- `spy()`で`globalThis.fetch`を差し替えれば、ネットワークアクセスなしの単体テストも実現できる。

### 7. テストとパーミッション・サニタイザ

- デフォルトでリソース・非同期操作・プロセス終了の開放漏れを検査し、問題があればテスト失敗。
- 必要に応じて`sanitizeResources: false`などで検査を無効化できる。

### 8. まとめ

Denoはテスト機能が充実しており、標準機能だけで多様なテストパターンに対応できる。

公式ドキュメントや標準ライブラリを活用し、プロジェクトに最適なテストスタイルを選択するのがよい。

### 参考リンク

- <https://docs.deno.com/runtime/fundamentals/testing/>
- <https://docs.deno.com/examples/writing_tests/>

---

## 2025-06-07: Next.js v15におけるデータフェッチパターンの進化と実践

Next.js v15（App
Router利用）でのデータフェッチ方法について、典型的なパターンとその課題、そして最新の推奨アプローチを整理する。

### 1. サーバーコンポーネントでの同期データフェッチ

`src/app/page.tsx`

```tsx
const getTodos = async () => {
  const response = await fetch('https://example.com/api/todos');
  if (!response.ok) {
    throw new Error('Failed to fetch todos');
  }
  return response;
};

export default async function HomePage() {
  const response = await getTodos();
  const todos = await response.json();

  return (
    <div>
      <h1>Todo</h1>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>{todo.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

#### 特徴・課題

- サーバーコンポーネントなのでSSRや静的生成の恩恵を受けられる。
- ただし、`getTodos`の完了までページ全体のレンダリングがブロックされるため、UXが悪化しやすい。

### 2. サスペンス＋サーバーコンポーネント分割

`src/app/page.tsx`

```tsx
import { Suspense } from 'react';
import { TodoList } from '@/components/todo-list';

export default function HomePage() {
  return (
    <div>
      <h1>Todo</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <TodoList />
      </Suspense>
    </div>
  );
}
```

`src/components/todo-list.tsx`

```tsx
const getTodos = async () => {
  const response = await fetch('https://example.com/api/todos');
  if (!response.ok) {
    throw new Error('Failed to fetch todos');
  }
  return response;
};

export async function TodoList() {
  const response = await getTodos();
  const todos = await response.json();

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  );
}
```

#### 特徴・課題

- Todoリスト部分だけを遅延レンダリングできるため、ページ全体のブロックを回避できる。
- ただし、サーバーコンポーネントではクライアント側のインタラクション（onClick等）が実装できない。

### 3. クライアントコンポーネントでのデータフェッチ

`src/components/todo-list.tsx`

```tsx
'use client';
import { useState, useEffect } from 'react';

const getTodos = async () => {
  const response = await fetch('https://example.com/api/todos');
  if (!response.ok) {
    throw new Error('Failed to fetch todos');
  }
  return response;
};

export function TodoList() {
  const [todos, setTodos] = useState([]);

  useEffect(() => {
    const fetchTodos = async () => {
      const response = await getTodos();
      const data = await response.json();
      setTodos(data);
    };
    fetchTodos();
  }, []);

  return (
    <ul>
      {todos.map(todo => (
        <li
          key={todo.id}
          onClick={() => {
            // クリックハンドラ例
            console.log(`Todo clicked: ${todo.title}`);
          }}
        >
          {todo.title}
        </li>
      ))}
    </ul>
  );
}
```

#### 特徴・課題

- クライアント側でインタラクションが実装できる。
- ただし、データフェッチもクライアント側になるため、初回表示が遅くなり、SSRや静的生成の恩恵がなくなる。

### 4. `use` APIによるサーバーデータのクライアント受け渡し

Next.js v15では、`use`
APIを使うことで「サーバーで取得したPromiseをクライアントコンポーネントに渡し、クライアント側でインタラクションも実装できる」パターンが推奨されている。

`src/app/page.tsx`

```tsx
import { Suspense } from 'react';
import { TodoList } from '@/components/todo-list';

const getTodos = async () => {
  const response = await fetch('https://example.com/api/todos');
  if (!response.ok) {
    throw new Error('Failed to fetch todos');
  }
  return response;
};

export default function HomePage() {
  // サーバーでPromiseを生成
  const todosPromise = getTodos();
  return (
    <div>
      <h1>Todo</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <TodoList todosPromise={todosPromise} />
      </Suspense>
    </div>
  );
}
```

`src/components/todo-list.tsx`

```tsx
'use client';
import { use } from 'react';

type Props = {
  todosPromise: Promise<Response>;
};

export function TodoList({ todosPromise }: Props) {
  // サーバーで生成されたPromiseをuseで解決
  const todosResponse = use(todosPromise);
  // 注意: .json()もPromiseなので、use(todosResponse.json())とするのが正確
  const todos = use(todosResponse.json());

  return (
    <ul>
      {todos.map(todo => (
        <li
          key={todo.id}
          onClick={() => {
            // クライアント側のインタラクション
            console.log(`Todo clicked: ${todo.title}`);
          }}
        >
          {todo.title}
        </li>
      ))}
    </ul>
  );
}
```

#### 特徴・メリット

- サーバーでデータ取得→クライアントでインタラクション、という責務分離ができる。
- SSR/SSGの恩恵を受けつつ、クライアント側でイベントハンドラ等も実装可能。
- Suspenseによるストリーミング表示も可能。

#### 注意点

- `use`はPromiseを受け取ってサスペンドするReactの新API。
- `todosResponse.json()`もPromiseなので、`use(todosResponse.json())`のように2段階で使う必要がある。
- サーバー→クライアント間で渡せるのは「Serializableな値」または「Responseオブジェクト」などに限られる。

### 5. パターン比較・選択指針

| パターン       | SSR/SSG | クライアントインタラクション | 初回表示速度      | 実装難易度 |
| -------------- | ------- | ---------------------------- | ----------------- | ---------- |
| サーバー同期   | ◎       | ×                            | △（全体ブロック） | 易         |
| サスペンス分割 | ◎       | ×                            | ○（部分遅延）     | 普通       |
| クライアント   | ×       | ◎                            | ×（遅い）         | 易         |
| use API        | ◎       | ◎                            | ◎                 | やや難     |

### まとめ

Next.js v15では、`use`
APIを活用した「サーバーでデータ取得→クライアントでインタラクション」のパターンが推奨される。これにより、SSR/SSGの恩恵とクライアント側の柔軟なUI操作を両立できる。従来のパターンとの違いや選択基準を理解し、要件に応じて最適な方法を選ぶことが重要。

### 参考リンク

- [How to fetch data and stream](https://nextjs.org/docs/app/getting-started/fetching-data)
- [This Next.js Data Fetching Pattern Is CRITICAL For Every Developer](https://youtu.be/bKm1rNaCFOo)

---

## 2025-06-06: CSSの`contain`プロパティ徹底解説 ― 使い方・用途・注意点

CSSの`contain`プロパティは、要素のレイアウトやスタイル、サイズ、内容の影響範囲を制限し、**パフォーマンス最適化**や**予期せぬ副作用の防止**に役立つ重要なプロパティ。

### どんなときに使う？

- **大規模なUIやSPAでのパフォーマンス改善**
  レイアウト再計算（reflow/repaint）の伝播を遮断し、変更の影響範囲を限定できる。
- **Web Componentsや再利用コンポーネントのカプセル化** スタイルやレイアウトの「漏れ」や「衝突」を防ぐ。
- **Container Queries（コンテナクエリ）利用時の必須指定** `contain: layout inline-size;` などが必要。

### `contain`プロパティの値と意味

- `none`: デフォルト値。コンテインメントなし。
- `strict`: すべてのコンテインメント（layout, style, size, paint）を有効化。
- `content`: layout, style, paint のコンテインメントを有効化（sizeは含まない）。
- `size`: 要素のサイズを外部に影響させない。
- `layout`: レイアウトの影響を遮断。
- `style`: スタイルの継承やカスケードの影響を遮断。
- `paint`: 描画の影響を遮断（主にパフォーマンス最適化目的）。
- `inline-size`, `block-size`: それぞれインライン軸・ブロック軸のサイズコンテインメント。

### 具体例

```css
.card {
  contain: layout style;
  width: 300px;
  height: 200px;
  background: lightblue;
}

.card__body {
  width: 100%;
  height: 100%;
  background: coral;
}
```

この例では、`.card`はレイアウトとスタイルのコンテインメントを持ち、内部の`.card__body`のスタイルやレイアウトが外部に影響しない。

### 注意点・落とし穴

- **overflow: auto/scrollとの併用時に注意** スクロール領域の計算が意図せず変わる場合がある。
- **size/layoutの指定で高さ・幅が0になることがある** 子要素のサイズに依存する場合、親要素のサイズが計算できなくなる。
- **Container Queries利用時は`contain`の指定が必須** `container-type: inline-size;` などと組み合わせる。
- **一部古いブラウザでは未対応の値がある** [Can I use: contain](https://caniuse.com/?search=contain) で要確認。

### よくあるユースケース

- ダッシュボードやカード型UIのパフォーマンス最適化
- Web Componentsやカスタム要素のカプセル化
- コンテナクエリを使ったレスポンシブデザイン

### 参考リンク

- [MDN: contain - CSS: Cascading Style Sheets | MDN](https://developer.mozilla.org/ja/docs/Web/CSS/contain)
- [CSS Containment Module Level 3](https://drafts.csswg.org/css-contain-3/)
- [Can I use: contain](https://caniuse.com/?search=contain)

---

## 2025-06-05: transformが使われている要素内でpositionする時の落とし穴と対策

CSSの`transform`プロパティが適用された要素は、**新しいコンテインニングブロック（containing
block）**や**スタッキングコンテキスト**を作成する。

そのため、`position: absolute`や`position: fixed`で子要素を配置する際、意図しない位置になることがある。

### 具体例

```css
.container {
  transform: translateX(100px);
  position: relative;
}

.child {
  position: absolute;
  top: 0;
  left: 0;
}
```

この場合、`.child`は`.container`の**変形後の領域の左上**を基準に配置される。

`.container`に`transform`がなければ、通常のレイアウトフローに従うが、`transform`があると「変形後のボックス」が基準点となる。

### よくあるトラブル

- **意図しないズレ**
  例えば、モーダルやツールチップなどを絶対配置したい場合、親要素に`transform`があると、思った場所に表示されないことがある。
- **position: fixedの挙動変化**
  通常`fixed`はビューポート基準だが、`transform`がかかった親要素内では、その親要素が基準になる。

### なぜこうなる？

- `transform`が適用されると、その要素は**containing block**（絶対配置や固定配置の基準）になる。
- これは仕様であり、`filter`や`perspective`など一部のプロパティでも同様。

### 対策・ベストプラクティス

- **絶対配置したい要素の親にtransformをかけない** レイアウト用の親要素と、transformを使う要素を分離する。
- **どうしてもtransformが必要な場合は、absolute/fixedの基準を意識して設計する**
- **position: relativeを併用して意図的に基準を作る** 必要に応じて、親要素の構造を見直す。

### 参考リンク・引用

- [transform - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/CSS/transform)
  > If the property has a value different from none, a stacking context will be created. In that case, the element will
  > act as a containing block for any position: fixed; or position: absolute; elements that it contains.
- [CSS: Containing block - MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block)
- [It’s always the stacking context. ](https://css-tricks.com/its-always-the-stacking-context/)

---

## 2025-06-04: Next.jsアプリのホスティング選択肢を徹底比較

Next.jsアプリケーションをホストする方法は、プロジェクトの規模、要件、運用体制により最適解が異なる。ここでは主要なホスティング方法の特徴とメリット・デメリットを整理し、選定のポイントを明確にする。

### 1. マネージドホスティング（PaaS）

#### Vercel（Next.js公式）

Next.jsと最も相性がよい公式PaaS。最新機能（Edge Functions、ISR、Middleware等）への対応が早い。

- **メリット**

  - Next.jsとの完全な互換性。
  - Git連携で簡単にデプロイ可能。
  - 自動スケーリング、CDN、画像最適化が標準搭載。
  - Preview Deploymentsや環境変数管理が容易。

- **デメリット**

  - 無料プランのビルド時間や帯域に制限が厳しい。
  - 商用や規模が大きい場合、有料プランが必須。
  - 独自のインフラ要件への対応は難しい。

#### Netlify（Jamstack特化）

静的サイトやサーバーレスAPIに特化したサービス。

- **メリット**

  - 静的エクスポート、サーバーレスFunctionsが簡単。
  - GitHub連携やCI/CDが容易。

- **デメリット**

  - Next.jsのSSRや動的ルーティングのサポートは限定的。
  - Next.jsのフル機能活用には注意が必要。

#### Cloudflare Pages

Cloudflareが提供するPaaS。Edgeでの動的コンテンツ提供に強み。

- **メリット**

  - 世界中のエッジネットワークを利用した高速な配信。
  - Git統合による簡単なデプロイ。
  - 無料プランが比較的充実している。
  - Workersとの組み合わせで動的コンテンツにも対応。

- **デメリット**

  - Next.jsの特定機能（ISR、Middleware等）の対応状況に注意が必要。
  - Vercelほど完全な機能互換性はない場合がある。

#### その他（AWS Amplify、Azure Static Web Appsなど）

- 大手クラウド提供のPaaSサービスだが、Next.js対応状況に差があるため要確認。

### 2. セルフホスティング（VPS・自前サーバー）

#### 静的エクスポート（`next export`）

Next.jsを静的サイトとしてビルドし、S3＋CloudFrontなどのCDNで配信。

- **メリット**

  - 高速、高可用性で低コスト。
  - サーバーレス運用が可能。

- **デメリット**

  - API Routes、SSR、ISRなど動的機能が使えない。
  - 更新のたびに再ビルドと再デプロイが必要。

#### Node.jsサーバー（VPS上）

VPSで直接Node.jsサーバーとしてNext.jsを運用。

- **メリット**

  - Next.js全機能（SSR/ISR/API Routes）が利用可能。
  - インフラやミドルウェアを自由にカスタマイズ。

- **デメリット**

  - サーバー運用の管理・セキュリティ・スケーリングの責任が発生。
  - インフラ運用の専門知識や監視体制が必要。

#### Dockerコンテナ運用

Dockerを使ってNext.jsアプリをコンテナ化し、VPSやクラウド環境で運用。

- **メリット**

  - 環境差異を吸収し、移植性が高い。
  - CI/CDやサービス連携が容易。

- **デメリット**

  - Dockerおよびオーケストレーション（Compose、Kubernetes）の知識が必要。
  - 構築や運用はやや複雑。

#### セルフホスト型PaaS（Coolify、Dokployなど）

VPSに独自のPaaS環境を構築。

- **メリット**

  - Vercel/Netlifyのようなユーザー体験をセルフホストで再現可能。
  - 複数プロジェクトの一元管理が容易。

- **デメリット**

  - PaaS自体のメンテナンスが必要。
  - 商用サービスより安定性や機能性が劣ることがある。

### 3. 選定のポイント・実践Tips

- **小規模・個人開発**：VercelやNetlifyが最適。無料枠内で簡単に運用可能。
- **商用・中〜大規模プロジェクト**：有料PaaSまたはセルフホスティング（Docker/VPS）を検討。SLA、セキュリティ、運用体制を考慮。
- **静的サイト中心**：静的エクスポート＋CDNが高速かつシンプル。
- **SSRや動的機能重視**：Node.jsサーバーまたはDockerコンテナでの運用が必須。
- **コスト重視**：セルフホスティングは初期コストを抑えられるが、運用負担がある。
- **学習・検証用途**：まずVercelで始め、ニーズに応じて他の方法に切り替えるとスムーズ。

### 4. 注意点

- Next.jsのバージョンや機能によってホスティングの対応状況が異なる場合があるため、事前に確認が必要。
- 商用利用ではSLAやセキュリティ、バックアップ体制を必ず確認。
- 運用を効率化するために、CI/CDや監視システムの整備を推奨。

### 参考リンク

- [How To Host Next.js In 2025 (VPS, Self-Hosting, Managed)](https://youtu.be/ze1zrmoElrs)
- [How to deploy your Next.js application](https://nextjs.org/docs/app/getting-started/deploying)

---

## 2025-06-03: TypeScriptの型操作テクニック集

TypeScriptで型を柔軟に扱うための実践的なテクニックや知見をまとめる。

API設計やライブラリ開発、アプリケーション実装時に役立つ型の使い分けや、ユーティリティ型の活用方法などを整理。

### Key OptionalとValue Optionalの違い

全てKey optionalのケース

```ts
const doThing = (ctx: { traceId?: string }) => {};

const doAnotherThing = (ctx: { traceId?: string }) => {};

export const mainFunction = (ctx: { traceId?: string }) => {
  doThing({}); // traceIdは省略可能
  doAnotherThing({}); // traceIdは省略可能
};

mainFunction({}); // traceIdは省略可能
```

一部Value optionalのケース

```ts
const doThing = (ctx: { traceId: string | undefined }) => {};

const doAnotherThing = (ctx: { traceId: string | undefined }) => {};

export const mainFunction = (ctx: { traceId?: string }) => {
  doThing({}); // traceIdは省略できない
  doAnotherThing({}); // traceIdは省略できない
};

mainFunction({}); // traceIdは省略可能
```

全てValue optionalのケース

```ts
const doThing = (ctx: { traceId: string | undefined }) => {};

const doAnotherThing = (ctx: { traceId: string | undefined }) => {};

export const mainFunction = (ctx: { traceId: string | undefined }) => {
  doThing({}); // traceIdは省略できない
  doAnotherThing({}); // traceIdは省略できない
};

mainFunction({}); // traceIdは省略できない
```

#### 使い分けのポイント

- 表出するAPIをきれいに提供するために、Key optionalにする
  - ライブラリコードで提供するならこっちが有効かも
- 渡すプロパティを必ず保証するために、Value optionalにする
  - アプリケーションコードではこっちが有効かも

### Pick/Omit vs Extract/Exclude

Pick/Omit

```ts
type Album = {
  title: string;
  artist: string;
  releaseYear?: number;
  genre?: {
    parentGenre?: string;
    subGenre?: string;
  };
};

type AlbumData1 = Pick<Album, 'title' | 'artist'>; // titleとartistのみを抽出

type AlbumData2 = Omit<Album, 'releaseYear' | 'genre'>; // releaseYearとgenreを除外
```

Extract/Exclude

```ts
type AlbumState =
  | { type: 'released'; releaseDate: string }
  | { type: 'recording'; studio: string }
  | { type; mixing; engineer: string };

type NotReleased = Exclude<AlbumState, { type: 'released' }>; // 'released'以外の状態を抽出
```

```ts
type Example = 'a' | 'b' | 1 | 2 | 'c';

type Strings = Extract<Example, string>; // string型の部分のみを抽出

type Numbers = Extract<Example, number>; // number型の部分のみを抽出
```

### Prettify

```ts
type ComplexType = {
  a: string;
  b: number;
} & {
  c: boolean;
} & {
  d: string[];
};

type ShowMe = ComplexType; // これをPrettifyしたい

type Prettify<T> = {
  [K in keyof T]: T[K];
} & {};

type PrettyShowMe = Prettify<ShowMe>; // これでPrettifyされる
```

#### 使い道

ライブラリコードで、ユーザー側が見やすく型を提供したいのなら特に有効かも

### Loose Autocomplete

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7';

const model1: ModelNames = 'gpt-4o'; // Autocompleteが効く
```

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7' | string;

const model1: ModelNames = ''; // Autocompleteは効かない
```

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7' | (string & {});

const model1: ModelNames = 'some-arbitrary-model'; // Autocompleteが効く
```

### Mapped Types

```ts
type User = {
  id: string;
  name: string;
  age: number;
};

// 全てのプロパティをそのままコピーする
type UserTransformed = {
  [K in keyof User]: User[K];
};

// 全てのプロパティを関数形式に変換する
type UserTransformedWithFunctions = {
  [K in keyof User as `get${Capitalize<K>}`]: () => User[K];
};
```

### 参考リンク

- [6 TypeScript tips to turn you into a WIZARD](https://youtu.be/lraHlXpuhKs)

---

## 2025-06-02: RemixがReactやめてPreactに移行するらしい

### 背景を知る

#### React Routerとの統合による役割の変化

Remix v2はReact Routerの薄いラッパーに過ぎなくなっており、その結果、両プロジェクト間に人工的な分離が生じていた。

この状況を解消するため、RemixのバンドラーやサーバーランタイムのコードをReact Router v7に統合し、Remixの主要な機能をReact
Router v7の「フレームワークモード」に組み込んだ。

これにより、Remix v1およびv2、さらには以前のReact
Routerバージョンで構築されたアプリケーションに対して、長期的なサポートを提供する安定したプラットフォームが実現した。

#### 新たな方向性とPreactの採用

React Routerが成熟し、堅牢なプラットフォームとなったことで、Remixは新たな方向性を模索する自由を得た。

その結果、Remix
v3では、より軽量でウェブ標準に近いアプローチを採用するため、ReactではなくPreact（正確にはそのフォーク）を選択した。

Preactは、Reactと同様のAPIを提供しつつ、サイズが小さく、パフォーマンスに優れている。

また、Preactは標準のブラウザイベントを使用し、DOM仕様により忠実であるため、ウェブプラットフォームとの親和性が高いとされている。

#### 現代のウェブ開発に対する再評価

Reactのエコシステムは強力である一方で、複雑さや抽象化の過剰さが問題視されている。

Josh
Collinsworth氏は、Reactが提供する抽象化が、開発者にとって本来のウェブのシンプルさを忘れさせてしまっていると指摘している。

例えば、Reactのフックや状態管理は強力だが、それが必ずしも最適解ではなく、他のアプローチ（例えば、PreactのSignalsなど）も検討に値すると述べている。

#### Remix v3の設計原則

Remix v3は、以下のような設計原則に基づいて構築されている。

- モデルファースト開発：AIと人間の両方が理解しやすいコードを目指す。
- ウェブAPIの活用：ブラウザの標準機能を最大限に活用し、不要な抽象化を避ける。
- ランタイム重視：ビルドツールやコンパイラに依存せず、実行時のシンプルさを追求する。
- 依存関係の最小化：外部ライブラリへの依存を減らし、自律的な開発を可能にする。

これらの原則は、Reactのような大規模なエコシステムから脱却し、より軽量で柔軟な開発体験を提供することを目的としている。

### まとめ

RemixがReactからPreactへと移行した背景には、技術的な最適化だけでなく、ウェブ開発の本質への回帰という哲学的な意図がある。

React
Routerとの統合によりRemixの役割が変化し、新たな方向性として、より軽量でウェブ標準に近いPreactを採用することで、開発者にとってシンプルで効率的なフレームワークを提供しようとしている。

### 参考リンク

- [Wake up, Remix!](https://remix.run/blog/wake-up-remix)
- [Things you forgot (or never knew) because of React](https://joshcollinsworth.com/blog/antiquated-react)
- [Differences to React](https://preactjs.com/guide/v10/differences-to-react)

---

## 2025-06-01: CSSのoklch指定について

CSSで色を指定する際に、`oklch`という新しい色空間が使えるようになってきた。

### oklchとは？

- oklchは「明度（L）」「彩度（C）」「色相（H）」で色を指定できる色空間。
- 直感的に「明るさ」「鮮やかさ」「色味」を個別にコントロールできる。
- sRGBやhslよりも人間の知覚に近い色変化が得られる。

### 例

```css
.button {
  background: oklch(80% 0.15 200);
  color: oklch(30% 0.02 40);
}
```

- 明度（L）を変えるだけで、自然な明るさ調整ができる。
- 彩度（C）を0に近づけるとグレースケールに。

### メリット

- アクセシビリティ対応（コントラスト調整）がしやすい
- ダークモード/ライトモードの色設計が直感的
- デザイントークンやカラーパレット生成に最適

### 注意点

- 2025年6月時点で、主要ブラウザの最新バージョンでほぼサポートされているが、古い環境では未対応の場合あり
- Figmaやデザインツール側の対応状況も要確認

### 参考リンク

- [OKLCH Color Picker](https://oklch.com/)
- [CSS Color 4: oklch()](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklch)

---

<!-- Template for new entries -->
<!--
## 2025-06-XX: [Topic Title]

[Description of what you learned today]

### Example/Code (if applicable)

```txt
# Code example here
```

### References

- [Reference link 1](https://example.com)
- [Reference link 2](https://example.com)
-->
