# June 2025 TIL (Today I Learned)

This file contains things I learned during June 2025.

---

## 2025-06-04: Next.jsアプリのホスティング選択肢を徹底比較

Next.jsアプリケーションをどこに、どのようにホストするかは、プロジェクトの規模・要件・運用体制によって最適解が異なる。ここでは主要なホスティング方法の特徴、メリット・デメリット、選定時のポイントを整理する。

### 1. マネージドホスティング（PaaS）

#### Vercel

Next.js公式が提供するPaaS。Next.jsの最新機能（Edge Functions, ISR, Middleware等）に最速で対応。

- **メリット**
  - Next.jsとの親和性が最高。デプロイがGit連携だけで完結。
  - 自動スケーリング、CDN、画像最適化などが標準。
  - Preview Deploymentsや環境変数管理も簡単。
- **デメリット**
  - 無料プランはビルド時間や帯域に厳しい制限。
  - 商用・大規模用途は有料プラン必須。
  - カスタムなインフラ要件には不向き。

#### Netlify

Jamstack系PaaSの代表格。静的サイトやサーバーレスAPIに強み。

- **メリット**
  - 静的エクスポートやサーバーレスFunctionsが簡単。
  - GitHub連携やCI/CDが容易。
- **デメリット**
  - Next.jsのSSRやDynamic Routesは一部制限あり。
  - Next.jsの全機能をフル活用したい場合は注意。

#### その他（AWS Amplify, Azure Static Web Apps等）

- **特徴**: 大手クラウドのPaaS。Next.js公式サポート状況や機能差異に注意。

### 2. セルフホスティング（VPS/自前サーバー）

#### Static Export（`next export`）

完全静的サイトとしてビルドし、S3+CloudFront等のCDNや静的ホスティングサービスで配信。

- **メリット**
  - サーバーレスで超高速・高可用性。
  - 運用コストが安い。
- **デメリット**
  - API RoutesやSSR/ISRなど動的機能は使えない。
  - 更新には再ビルド・再デプロイが必要。

#### Node.jsサーバー（VPS上）

VPS上でNode.jsサーバーとしてNext.jsを動かす。自由度が高い。

- **メリット**
  - SSR/ISR/API RoutesなどNext.jsの全機能が利用可能。
  - ミドルウェアや独自構成も自由。
- **デメリット**
  - サーバー運用・セキュリティ・スケーリングの責任が発生。
  - インフラ知識・監視体制が必要。

#### Dockerコンテナ運用

Next.jsアプリをDocker化し、VPSやクラウド上で運用。

- **メリット**
  - 環境差異を吸収しやすく、移植性・再現性が高い。
  - CI/CDや複数サービス連携も容易。
- **デメリット**
  - Dockerやオーケストレーション（例: Compose, Kubernetes）の知識が必要。
  - 初期構築や運用がやや複雑。

#### 自前PaaS系（Coolify, Dokploy等）

VPS上にセルフホスト型PaaSを構築し、GUIでデプロイ管理。

- **メリット**
  - Vercel/Netlifyに近い体験を自前で実現可能。
  - 複数プロジェクトの一元管理もできる。
- **デメリット**
  - プラットフォーム自体のメンテナンスが必要。
  - 機能や安定性は商用PaaSに劣る場合あり。

### 3. 選定のポイント・実践Tips

- **小規模・個人開発**: VercelやNetlifyが最速・最楽。無料枠で十分な場合も多い。
- **商用・中〜大規模**: 有料PaaS or セルフホスティング（Docker/VPS）を検討。SLAや運用体制も考慮。
- **静的サイト中心**: Static Export + CDNが最もシンプルで高速。
- **SSR/動的機能重視**: Node.jsサーバー or Docker運用が必須。
- **コスト重視**: セルフホスティングは初期コストが低いが、運用負荷に注意。
- **学習・検証用途**: まずはVercelで始めて、必要に応じて他方式へ移行も容易。

### 4. 注意点

- Next.jsのバージョンや機能によって、各ホスティングの対応状況が異なる場合がある。
- 商用利用や大規模運用では、SLA・セキュリティ・バックアップ体制も要確認。
- サーバーレス/セルフホストのどちらも、CI/CDや監視の仕組みを整備すると運用が楽になる。

### 参考リンク

- [How To Host Next.js In 2025 (VPS, Self-Hosting, Managed)](https://youtu.be/ze1zrmoElrs)
- [How to deploy your Next.js application](https://nextjs.org/docs/app/getting-started/deploying)

---

## 2025-06-03: TypeScriptの型操作テクニック集

TypeScriptで型を柔軟に扱うための実践的なテクニックや知見をまとめる。

API設計やライブラリ開発、アプリケーション実装時に役立つ型の使い分けや、ユーティリティ型の活用方法などを整理。

### Key OptionalとValue Optionalの違い

全てKey optionalのケース

```ts
const doThing = (ctx: { traceId?: string }) => {};

const doAnotherThing = (ctx: { traceId?: string }) => {};

export const mainFunction = (ctx: { traceId?: string }) => {
  doThing({}); // traceIdは省略可能
  doAnotherThing({}); // traceIdは省略可能
};

mainFunction({}); // traceIdは省略可能
```

一部Value optionalのケース

```ts
const doThing = (ctx: { traceId: string | undefined }) => {};

const doAnotherThing = (ctx: { traceId: string | undefined }) => {};

export const mainFunction = (ctx: { traceId?: string }) => {
  doThing({}); // traceIdは省略できない
  doAnotherThing({}); // traceIdは省略できない
};

mainFunction({}); // traceIdは省略可能
```

全てValue optionalのケース

```ts
const doThing = (ctx: { traceId: string | undefined }) => {};

const doAnotherThing = (ctx: { traceId: string | undefined }) => {};

export const mainFunction = (ctx: { traceId: string | undefined }) => {
  doThing({}); // traceIdは省略できない
  doAnotherThing({}); // traceIdは省略できない
};

mainFunction({}); // traceIdは省略できない
```

#### 使い分けのポイント

- 表出するAPIをきれいに提供するために、Key optionalにする
  - ライブラリコードで提供するならこっちが有効かも
- 渡すプロパティを必ず保証するために、Value optionalにする
  - アプリケーションコードではこっちが有効かも

### Pick/Omit vs Extract/Exclude

Pick/Omit

```ts
type Album = {
  title: string;
  artist: string;
  releaseYear?: number;
  genre?: {
    parentGenre?: string;
    subGenre?: string;
  };
};

type AlbumData1 = Pick<Album, 'title' | 'artist'>; // titleとartistのみを抽出

type AlbumData2 = Omit<Album, 'releaseYear' | 'genre'>; // releaseYearとgenreを除外
```

Extract/Exclude

```ts
type AlbumState =
  | { type: 'released'; releaseDate: string }
  | { type: 'recording'; studio: string }
  | { type; mixing; engineer: string };

type NotReleased = Exclude<AlbumState, { type: 'released' }>; // 'released'以外の状態を抽出
```

```ts
type Example = 'a' | 'b' | 1 | 2 | 'c';

type Strings = Extract<Example, string>; // string型の部分のみを抽出

type Numbers = Extract<Example, number>; // number型の部分のみを抽出
```

### Prettify

```ts
type ComplexType = {
  a: string;
  b: number;
} & {
  c: boolean;
} & {
  d: string[];
};

type ShowMe = ComplexType; // これをPrettifyしたい

type Prettify<T> = {
  [K in keyof T]: T[K];
} & {};

type PrettyShowMe = Prettify<ShowMe>; // これでPrettifyされる
```

#### 使い道

ライブラリコードで、ユーザー側が見やすく型を提供したいのなら特に有効かも

### Loose Autocomplete

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7';

const model1: ModelNames = 'gpt-4o'; // Autocompleteが効く
```

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7' | string;

const model1: ModelNames = ''; // Autocompleteは効かない
```

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7' | (string & {});

const model1: ModelNames = 'some-arbitrary-model'; // Autocompleteが効く
```

### Mapped Types

```ts
type User = {
  id: string;
  name: string;
  age: number;
};

// 全てのプロパティをそのままコピーする
type UserTransformed = {
  [K in keyof User]: User[K];
};

// 全てのプロパティを関数形式に変換する
type UserTransformedWithFunctions = {
  [K in keyof User as `get${Capitalize<K>}`]: () => User[K];
};
```

### 参考リンク

- [6 TypeScript tips to turn you into a WIZARD](https://youtu.be/lraHlXpuhKs)

---

## 2025-06-02: RemixがReactやめてPreactに移行するらしい

### 背景を知る

#### React Routerとの統合による役割の変化

Remix v2はReact Routerの薄いラッパーに過ぎなくなっており、その結果、両プロジェクト間に人工的な分離が生じていた。

この状況を解消するため、RemixのバンドラーやサーバーランタイムのコードをReact Router v7に統合し、Remixの主要な機能をReact
Router v7の「フレームワークモード」に組み込んだ。

これにより、Remix v1およびv2、さらには以前のReact
Routerバージョンで構築されたアプリケーションに対して、長期的なサポートを提供する安定したプラットフォームが実現した。

#### 新たな方向性とPreactの採用

React Routerが成熟し、堅牢なプラットフォームとなったことで、Remixは新たな方向性を模索する自由を得た。

その結果、Remix
v3では、より軽量でウェブ標準に近いアプローチを採用するため、ReactではなくPreact（正確にはそのフォーク）を選択した。

Preactは、Reactと同様のAPIを提供しつつ、サイズが小さく、パフォーマンスに優れている。

また、Preactは標準のブラウザイベントを使用し、DOM仕様により忠実であるため、ウェブプラットフォームとの親和性が高いとされている。

#### 現代のウェブ開発に対する再評価

Reactのエコシステムは強力である一方で、複雑さや抽象化の過剰さが問題視されている。

Josh
Collinsworth氏は、Reactが提供する抽象化が、開発者にとって本来のウェブのシンプルさを忘れさせてしまっていると指摘している。

例えば、Reactのフックや状態管理は強力だが、それが必ずしも最適解ではなく、他のアプローチ（例えば、PreactのSignalsなど）も検討に値すると述べている。

#### Remix v3の設計原則

Remix v3は、以下のような設計原則に基づいて構築されている。

- モデルファースト開発：AIと人間の両方が理解しやすいコードを目指す。
- ウェブAPIの活用：ブラウザの標準機能を最大限に活用し、不要な抽象化を避ける。
- ランタイム重視：ビルドツールやコンパイラに依存せず、実行時のシンプルさを追求する。
- 依存関係の最小化：外部ライブラリへの依存を減らし、自律的な開発を可能にする。

これらの原則は、Reactのような大規模なエコシステムから脱却し、より軽量で柔軟な開発体験を提供することを目的としている。

### まとめ

RemixがReactからPreactへと移行した背景には、技術的な最適化だけでなく、ウェブ開発の本質への回帰という哲学的な意図がある。

React
Routerとの統合によりRemixの役割が変化し、新たな方向性として、より軽量でウェブ標準に近いPreactを採用することで、開発者にとってシンプルで効率的なフレームワークを提供しようとしている。

### 参考リンク

- [Wake up, Remix!](https://remix.run/blog/wake-up-remix)
- [Things you forgot (or never knew) because of React](https://joshcollinsworth.com/blog/antiquated-react)
- [Differences to React](https://preactjs.com/guide/v10/differences-to-react)

---

## 2025-06-01: CSSのoklch指定について

CSSで色を指定する際に、`oklch`という新しい色空間が使えるようになってきた。

### oklchとは？

- oklchは「明度（L）」「彩度（C）」「色相（H）」で色を指定できる色空間。
- 直感的に「明るさ」「鮮やかさ」「色味」を個別にコントロールできる。
- sRGBやhslよりも人間の知覚に近い色変化が得られる。

### 例

```css
.button {
  background: oklch(80% 0.15 200);
  color: oklch(30% 0.02 40);
}
```

- 明度（L）を変えるだけで、自然な明るさ調整ができる。
- 彩度（C）を0に近づけるとグレースケールに。

### メリット

- アクセシビリティ対応（コントラスト調整）がしやすい
- ダークモード/ライトモードの色設計が直感的
- デザイントークンやカラーパレット生成に最適

### 注意点

- 2025年6月時点で、主要ブラウザの最新バージョンでほぼサポートされているが、古い環境では未対応の場合あり
- Figmaやデザインツール側の対応状況も要確認

### 参考リンク

- [OKLCH Color Picker](https://oklch.com/)
- [CSS Color 4: oklch()](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklch)

---

<!-- Template for new entries -->
<!--
## 2025-06-XX: [Topic Title]

[Description of what you learned today]

### Example/Code (if applicable)

```txt
# Code example here
```

### References

- [Reference link 1](https://example.com)
- [Reference link 2](https://example.com)
-->
