# June 2025 TIL (Today I Learned)

This file contains things I learned during June 2025.

---

## 2025-06-03: TypeScriptの型操作テクニック集

TypeScriptで型を柔軟に扱うための実践的なテクニックや知見をまとめる。

API設計やライブラリ開発、アプリケーション実装時に役立つ型の使い分けや、ユーティリティ型の活用方法などを整理。

### Key OptionalとValue Optionalの違い

全てKey optionalのケース

```ts
const doThing = (ctx: { traceId?: string }) => {};

const doAnotherThing = (ctx: { traceId?: string }) => {};

export const mainFunction = (ctx: { traceId?: string }) => {
  doThing({}); // traceIdは省略可能
  doAnotherThing({}); // traceIdは省略可能
};

mainFunction({}); // traceIdは省略可能
```

一部Value optionalのケース

```ts
const doThing = (ctx: { traceId: string | undefined }) => {};

const doAnotherThing = (ctx: { traceId: string | undefined }) => {};

export const mainFunction = (ctx: { traceId?: string }) => {
  doThing({}); // traceIdは省略できない
  doAnotherThing({}); // traceIdは省略できない
};

mainFunction({}); // traceIdは省略可能
```

全てValue optionalのケース

```ts
const doThing = (ctx: { traceId: string | undefined }) => {};

const doAnotherThing = (ctx: { traceId: string | undefined }) => {};

export const mainFunction = (ctx: { traceId: string | undefined }) => {
  doThing({}); // traceIdは省略できない
  doAnotherThing({}); // traceIdは省略できない
};

mainFunction({}); // traceIdは省略できない
```

#### 使い分けのポイント

- 表出するAPIをきれいに提供するために、Key optionalにする
  - ライブラリコードで提供するならこっちが有効かも
- 渡すプロパティを必ず保証するために、Value optionalにする
  - アプリケーションコードではこっちが有効かも

### Pick/Omit vs Extract/Exclude

Pick/Omit

```ts
type Album = {
  title: string;
  artist: string;
  releaseYear?: number;
  genre?: {
    parentGenre?: string;
    subGenre?: string;
  };
};

type AlbumData1 = Pick<Album, 'title' | 'artist'>; // titleとartistのみを抽出

type AlbumData2 = Omit<Album, 'releaseYear' | 'genre'>; // releaseYearとgenreを除外
```

Extract/Exclude

```ts
type AlbumState =
  | { type: 'released'; releaseDate: string }
  | { type: 'recording'; studio: string }
  | { type; mixing; engineer: string };

type NotReleased = Exclude<AlbumState, { type: 'released' }>; // 'released'以外の状態を抽出
```

```ts
type Example = 'a' | 'b' | 1 | 2 | 'c';

type Strings = Extract<Example, string>; // string型の部分のみを抽出

type Numbers = Extract<Example, number>; // number型の部分のみを抽出
```

### Prettify

```ts
type ComplexType = {
  a: string;
  b: number;
} & {
  c: boolean;
} & {
  d: string[];
};

type ShowMe = ComplexType; // これをPrettifyしたい

type Prettify<T> = {
  [K in keyof T]: T[K];
} & {};

type PrettyShowMe = Prettify<ShowMe>; // これでPrettifyされる
```

#### 使い道

ライブラリコードで、ユーザー側が見やすく型を提供したいのなら特に有効かも

### Loose Autocomplete

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7';

const model1: ModelNames = 'gpt-4o'; // Autocompleteが効く
```

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7' | string;

const model1: ModelNames = ''; // Autocompleteは効かない
```

```ts
type ModelNames = 'gpt-4o' | 'o3-mini' | 'claude-sonnet-3.7' | (string & {});

const model1: ModelNames = 'some-arbitrary-model'; // Autocompleteが効く
```

### Mapped Types

```ts
type User = {
  id: string;
  name: string;
  age: number;
};

// 全てのプロパティをそのままコピーする
type UserTransformed = {
  [K in keyof User]: User[K];
};

// 全てのプロパティを関数形式に変換する
type UserTransformedWithFunctions = {
  [K in keyof User as `get${Capitalize<K>}`]: () => User[K];
};
```

### 参考リンク

- [6 TypeScript tips to turn you into a WIZARD](https://youtu.be/lraHlXpuhKs)

---

## 2025-06-02: RemixがReactやめてPreactに移行するらしい

### 背景を知る

#### React Routerとの統合による役割の変化

Remix v2はReact Routerの薄いラッパーに過ぎなくなっており、その結果、両プロジェクト間に人工的な分離が生じていた。

この状況を解消するため、RemixのバンドラーやサーバーランタイムのコードをReact Router v7に統合し、Remixの主要な機能をReact
Router v7の「フレームワークモード」に組み込んだ。

これにより、Remix v1およびv2、さらには以前のReact
Routerバージョンで構築されたアプリケーションに対して、長期的なサポートを提供する安定したプラットフォームが実現した。

#### 新たな方向性とPreactの採用

React Routerが成熟し、堅牢なプラットフォームとなったことで、Remixは新たな方向性を模索する自由を得た。

その結果、Remix
v3では、より軽量でウェブ標準に近いアプローチを採用するため、ReactではなくPreact（正確にはそのフォーク）を選択した。

Preactは、Reactと同様のAPIを提供しつつ、サイズが小さく、パフォーマンスに優れている。

また、Preactは標準のブラウザイベントを使用し、DOM仕様により忠実であるため、ウェブプラットフォームとの親和性が高いとされている。

#### 現代のウェブ開発に対する再評価

Reactのエコシステムは強力である一方で、複雑さや抽象化の過剰さが問題視されている。

Josh
Collinsworth氏は、Reactが提供する抽象化が、開発者にとって本来のウェブのシンプルさを忘れさせてしまっていると指摘している。

例えば、Reactのフックや状態管理は強力だが、それが必ずしも最適解ではなく、他のアプローチ（例えば、PreactのSignalsなど）も検討に値すると述べている。

#### Remix v3の設計原則

Remix v3は、以下のような設計原則に基づいて構築されている。

- モデルファースト開発：AIと人間の両方が理解しやすいコードを目指す。
- ウェブAPIの活用：ブラウザの標準機能を最大限に活用し、不要な抽象化を避ける。
- ランタイム重視：ビルドツールやコンパイラに依存せず、実行時のシンプルさを追求する。
- 依存関係の最小化：外部ライブラリへの依存を減らし、自律的な開発を可能にする。

これらの原則は、Reactのような大規模なエコシステムから脱却し、より軽量で柔軟な開発体験を提供することを目的としている。

### まとめ

RemixがReactからPreactへと移行した背景には、技術的な最適化だけでなく、ウェブ開発の本質への回帰という哲学的な意図がある。

React
Routerとの統合によりRemixの役割が変化し、新たな方向性として、より軽量でウェブ標準に近いPreactを採用することで、開発者にとってシンプルで効率的なフレームワークを提供しようとしている。

### 参考リンク

- [Wake up, Remix!](https://remix.run/blog/wake-up-remix)
- [Things you forgot (or never knew) because of React](https://joshcollinsworth.com/blog/antiquated-react)
- [Differences to React](https://preactjs.com/guide/v10/differences-to-react)

---

## 2025-06-01: CSSのoklch指定について

CSSで色を指定する際に、`oklch`という新しい色空間が使えるようになってきた。

### oklchとは？

- oklchは「明度（L）」「彩度（C）」「色相（H）」で色を指定できる色空間。
- 直感的に「明るさ」「鮮やかさ」「色味」を個別にコントロールできる。
- sRGBやhslよりも人間の知覚に近い色変化が得られる。

### 例

```css
.button {
  background: oklch(80% 0.15 200);
  color: oklch(30% 0.02 40);
}
```

- 明度（L）を変えるだけで、自然な明るさ調整ができる。
- 彩度（C）を0に近づけるとグレースケールに。

### メリット

- アクセシビリティ対応（コントラスト調整）がしやすい
- ダークモード/ライトモードの色設計が直感的
- デザイントークンやカラーパレット生成に最適

### 注意点

- 2025年6月時点で、主要ブラウザの最新バージョンでほぼサポートされているが、古い環境では未対応の場合あり
- Figmaやデザインツール側の対応状況も要確認

### 参考リンク

- [OKLCH Color Picker](https://oklch.com/)
- [CSS Color 4: oklch()](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklch)

---

<!-- Template for new entries -->
<!--
## 2025-06-XX: [Topic Title]

[Description of what you learned today]

### Example/Code (if applicable)

```txt
# Code example here
```

### References

- [Reference link 1](https://example.com)
- [Reference link 2](https://example.com)
-->
