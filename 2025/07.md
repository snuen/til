# July 2025 TIL (Today I Learned)

This file contains things I learned during July 2025.

---

## 2025-07-05: Reactのダウンサイドについて

昨日に参考にした記事に関連して、Reactのダウンサイドについての考察。

「[React Still Feels Insane And No One Is Talking About It](https://mbrizic.com/blog/react-is-insane/)」の要約

### 背景

筆者は最近のサイドプロジェクトでReactを使用し、改めてReactの問題点について考察している。過去にはAngular.JSやjQueryを使用した経験があり、フロントエンド技術の変遷を見てきた立場から論じている。

### 主な批判点

1. アーキテクチャの問題

- Reactはライブラリでありながら、暗黙的に「コンポーネントベースアーキテクチャ」を強制している
- 状態管理において、トップダウンでデータを渡すのは煩雑で、React
  Hooksによる「サイドローディング」はグローバル変数と本質的に同じ問題を抱えている

1. React Hooksの複雑さ

- useEffectが「副作用」を処理するためのものでありながら、コンポーネントの初期化にも使われている矛盾
- 複数のuseEffectが依存関係で連鎖し、実行順序を理解するのが困難
- 本来シンプルな命令型コードが非同期関数に分散され、可読性が大幅に低下

1. 設計パターンの複雑化

- Reactの「設計パターン」は過度に複雑で、単純なリスト表示でさえ大きなメンタルオーバーヘッドを生む
- CSS-in-JSのような手法はさらに複雑さを増している

### 根本的な問題の分析

なぜこうなったのか

- 多くのWebアプリは本来SPAである必要がない
- サーバーサイドレンダリングの方がはるかにシンプルで効率的
- インタラクティブなUIは「潜在的に無限の入力と出力」を持つ、ソフトウェアで最も複雑な問題の一つ

解決策の提案

1. 入力の削減: 機能やボタンの数を減らす
1. 出力の削減: サーバーサイドレンダリングを基本とし、必要な部分のみにReactを使用する「インタラクティビティの島」アプローチ

### 結論

筆者は最終的に、この複雑さはReact固有の問題ではなく、インタラクティブなUIを構築すること自体の本質的な困難さに由来すると結論づけている。どのような技術を選択しても、リアクティブなUIの複雑さの前では限界があるという認識を示している。

---

## 2025-07-04: 技術学習戦略の再考 - フレームワーク特化 vs 基礎技術投資

2つの記事から、技術者のキャリアにおける学習戦略の根本的な問題提起を学んだ。

### 核心的な問題提起

**「限られた時間で何を学ぶべきか」** - 技術者にとって最も重要な意思決定の一つ。

#### Keith Cirkelの主張（["NO TIME TO LEARN REACT"](https://www.keithcirkel.co.uk/i-dont-have-time-to-learn-react/)）

**背景**: 20年以上のWeb開発経験を持つベテラン開発者（Chai.jsの中核メンテナー）が、React
Hooksの登場で変化したReactエコシステムを前に抱いた疑問。

**3つの懸念点**:

1. **転用可能性の欠如**: フックのルールはReact特有で他フレームワークでは使えない
2. **偽の関数型プログラミング**: 真の関数型言語（Haskell、Elixir）を学ぶ方が価値がある
3. **時代遅れのUIパラダイム**: 2013年レベルのUIに留まっており、現代的な機能に対応していない

#### Wouter Groenevedの定量的分析（["No Time To Learn (Web) Framework X"](https://brainbaking.com/post/2025/06/no-time-to-learn-web-framework-x/)）

**Stack Overflowデータに基づく実証分析**:

- 大規模フレームワーク（jQuery、Angular、React、Vue）の推移
- 小規模フレームワーク（Meteor、Backbone、Ember）の衰退
- フレームワークのメジャーリリース（2年周期）による再学習コスト

**個人体験の証言**: AngularJS 1、ExtJS、Vaadin、JSF等の知識が無用化する一方、vanilla
JavaScriptやJavaの知識は長期間有用。

### 実践的な学習戦略の提案

#### 1. 基礎技術への投資優先（推奨）

**転用可能な基礎スキル**:

- **動的言語**: TypeScriptに依存しないJavaScript、Ruby、Python
- **システム言語**: Go、Zig、Rust（現代的な強型付け言語）
- **仕様書理解**: HTTP、HTML、CSS等の標準仕様
- **オープンソース貢献**: 実際の配信スキルと継続的学習

#### 2. フレームワーク学習の実用的指針

**最小限の学習**: 就職に必要な基本レベルに留める **選択基準**: 成熟度（v1.0以降）、コミュニティサイズ、破壊的変更の頻度
**投資時間**: 全体の20%以下に制限

#### 3. 長期的価値の評価軸

**技術選択の判断基準**:

```text
価値 = 転用可能性 × 持続期間 × 学習コスト^(-1)
```

**例**:

- HTTP仕様: 高い転用可能性 × 長期持続 × 低い学習コスト = 高価値
- React Hooks: 低い転用可能性 × 中期持続 × 高い学習コスト = 低価値

### 現代的な技術学習フレームワーク

#### レイヤー別学習戦略

```text
Layer 4: フレームワーク特化 (React, Vue, Angular)
         ↓ 最小限の投資
Layer 3: 言語生態系 (JavaScript, TypeScript, Node.js)
         ↓ 中程度の投資
Layer 2: 基礎言語 (JavaScript, Go, Rust)
         ↓ 重点投資
Layer 1: 仕様・プロトコル (HTTP, HTML, CSS)
         ↓ 最重要投資
```

#### 時間配分の実践例

**週40時間の学習時間配分**:

- 基礎技術・仕様: 20時間（50%）
- 言語習得: 12時間（30%）
- フレームワーク: 8時間（20%）

### 実装すべき行動変容

#### 1. 学習投資の ROI 計算

**新技術評価チェックリスト**:

- [ ] この技術は5年後も使われているか？
- [ ] 他の技術・領域でも応用可能か？
- [ ] 学習コストに見合うリターンが期待できるか？
- [ ] 代替技術との差別化要因は何か？

#### 2. 「学習債務」の管理

**技術債務ならぬ「学習債務」**: 短期的な利益（就職、案件獲得）のために長期的価値の低い技術を学ぶこと。

**債務削減戦略**:

- フレームワーク特化の学習時間を段階的に減らす
- 基礎技術の学習時間を計画的に増やす
- 定期的な学習ポートフォリオの見直し

#### 3. メンタルモデルの転換

**従来**: 「新しい技術 = 学ぶべき技術」 **新しい**: 「新しい技術 = 慎重に評価すべき技術」

### 個人的な実践方針

#### 即座に実装する変更

1. **React/Vue学習時間の削減**: 現在の50% → 20%へ
2. **Go/Rust学習の開始**: 週3時間の確保
3. **HTTP/CSS仕様書の定期読書**: 週1時間
4. **TypeScript(JavaScript)強化**: フレームワーク抜きでの実装練習

#### 長期的な目標設定

- **2025年内**: システム言語（Go/Rust）の基礎習得
- **2026年内**: Web標準仕様の体系的理解
- **継続的**: オープンソース貢献を通じた実践的スキル向上

### 反省と教訓

**従来の学習方針の問題点**:

- フレームワークの新機能に過度に反応
- 基礎技術の学習を後回し
- 短期的な市場価値を過度に重視

**新しい学習哲学**:

- 技術の本質的価値を見極める
- 長期的な競争優位性を構築する
- 学習投資の戦略的配分を意識する

この気づきは、技術者としての成長戦略を根本的に見直す契機となった。「何を学ぶか」よりも「何を学ばないか」の判断こそが、限られた時間を最大限に活用する鍵である。

---

## 2025-07-03: ClaudeのProjectsでのAI Driven Developmentの実践

Claudeの機能であるProjectsを使って、AI Driven Developmentの実践可能性を検証してみた。

### Projects機能の概要

Projects配下で、プロジェクト単位でナレッジを改めて紐づけることができるのだが、そのナレッジをClaude側がプロジェクト内のチャットで毎回参照してくれるというものらしい。

#### 基本構成要素

- **プロジェクト設定**: プロジェクト名と簡単な説明
- **プロジェクトナレッジ**: プロジェクトの目的、技術スタック、関連するドキュメント、開発ルール等
- **コンテキスト継承**: プロジェクト内のチャットで、登録されたナレッジを自動的に参照して回答

### 実践例: Reactカレンダーアプリ

プロジェクト名が「Reactカレンダーアプリ」で、目的が「ユーザーがカレンダーを操作できるUIを提供する」場合の設定例:

#### プロジェクトナレッジ設定

- **目的**: ユーザーがカレンダーを操作できるUIを提供する
- **技術スタック**: React, Redux, TypeScript
- **関連ドキュメント**:
  - [React公式ドキュメント](https://react.dev/)
  - [Redux公式ドキュメント](https://redux.js.org/)
- **プロジェクトのルール**: コードはESLintでチェックし、Prettierでフォーマットする
- **開発環境**: Node.js 20以上
- **API仕様**: カレンダーのデータはREST APIで取得し、JSON形式で返す
- **テストフレームワーク**: JestとReact Testing Libraryを使用
- **デプロイ方法**: Vercelを使用してデプロイする
- **CI/CD**: GitHub Actionsを使用して、プルリクエスト時に自動テストとデプロイを行う

#### 実際の会話例

**質問**: 「カレンダーコンポーネントで月の切り替えを実装したい」

**Claude回答（プロジェクトナレッジ参照）**:
Redux状態管理を使用して、月の切り替えを実装しましょう。TypeScriptでの型安全性を確保し、ESLint/Prettierルールに従って実装します。

### AI Driven Developmentの効果検証

#### メリット

1. **コンテキスト継続性**: プロジェクト固有の制約や方針を毎回説明する必要がない
2. **一貫性確保**: 技術スタックや開発ルールが自動的に適用される
3. **効率化**: 過去の決定事項や設計方針を再利用できる
4. **知識の構造化**: プロジェクト知識が体系的に整理される

#### 注意点・制約

1. **初期設定の重要性**: ナレッジ設定の品質が回答品質に直結
2. **更新の必要性**: プロジェクトの進化に伴うナレッジの更新が必要
3. **複雑性の管理**: 大規模プロジェクトでは情報量が膨大になる可能性

### 効果的なナレッジ構成のベストプラクティス

#### 1. 階層的な情報構造

```text
プロジェクト概要
├── 技術仕様
│   ├── 技術スタック
│   ├── アーキテクチャ
│   └── 開発環境
├── 開発ルール
│   ├── コーディング規約
│   ├── テスト方針
│   └── デプロイ手順
└── 参考資料
    ├── 外部ドキュメント
    ├── 設計決定記録
    └── トラブルシューティング
```

#### 2. コンテキストの粒度調整

- **Too Fine**: 詳細すぎる実装レベルの情報
- **Too Coarse**: 抽象的すぎる概念レベルの情報
- **Just Right**: 開発判断に必要な適切な抽象化レベル

#### 3. 進化的な知識管理

- プロジェクト進行に合わせた段階的な知識追加
- 過去の決定事項の記録と更新
- 失敗事例や制約事項の明文化

### 開発フローへの統合

#### 従来の開発フロー

```text
要件定義 → 設計 → 実装 → テスト → デプロイ
```

#### AI Driven Development with Projects

```text
要件定義 → ナレッジ設定 → AI協調設計 → AI支援実装 → AI検証テスト → デプロイ
```

各段階でProjectsナレッジを活用することで、一貫性のある開発が可能となる。

### 今後の展望

- **チーム開発**: 複数開発者間でのナレッジ共有
- **継続的改善**: 開発過程での知識蓄積とフィードバック
- **自動化**: CI/CDパイプラインとの統合可能性

### 実践的なナレッジ設定テンプレート

#### プロジェクト設定JSON例

```json
{
  "project": {
    "name": "React Calendar App",
    "description": "Interactive calendar UI with Redux state management",
    "tech_stack": ["React", "Redux", "TypeScript", "Vite"],
    "architecture": "Component-based SPA",
    "development_rules": {
      "linting": "ESLint + Prettier",
      "testing": "Jest + React Testing Library",
      "state_management": "Redux Toolkit",
      "styling": "CSS Modules + Tailwind CSS"
    },
    "api_specification": {
      "base_url": "https://api.calendar.example.com",
      "endpoints": {
        "calendar_data": "GET /api/calendar/:year/:month",
        "events": "GET /api/events",
        "create_event": "POST /api/events"
      },
      "authentication": "Bearer token"
    },
    "deployment": {
      "platform": "Vercel",
      "environment_variables": ["VITE_API_BASE_URL", "VITE_API_KEY"],
      "build_command": "npm run build",
      "preview_command": "npm run preview"
    }
  }
}
```

#### 開発ワークフロー例

```typescript
// AI支援開発での典型的なやり取り

// 1. 要件確認
"新しいイベント作成機能を追加したい"

// 2. AI応答（プロジェクトナレッジ参照）
"Redux Toolkitを使用してイベント作成機能を実装しましょう。
TypeScriptでの型安全性を確保し、React Testing Libraryでテストも含めます。"

// 3. 実装提案
interface CreateEventPayload {
  title: string;
  date: string;
  description?: string;
}

const createEventSlice = createSlice({
  name: 'events',
  initialState: {
    events: [] as Event[],
    loading: false,
    error: null
  },
  reducers: {
    createEventStart: (state) => {
      state.loading = true;
    },
    createEventSuccess: (state, action) => {
      state.events.push(action.payload);
      state.loading = false;
    },
    createEventFailure: (state, action) => {
      state.error = action.payload;
      state.loading = false;
    }
  }
});
```

### References

- [Claude Projects Documentation](https://support.anthropic.com/en/articles/9517075-what-are-projects)
- [AI-Driven Development Best Practices](https://www.anthropic.com/news/claude-3-family)

---

## 2025-07-02: Reactでのカレンダー操作とAPIリクエスト最適化の学び

### 課題

- カレンダーUIで「前月」「次月」ボタンを連打すると、不要なAPIリクエストが大量に発生する。
- クリック直後の状態はまだ反映されていない（`useSelector`で取得しているstateは、reducer適用の1フレーム後にしか変わらない）ため、連打時に**最終表示状態ではなく“途中の状態”でAPIが複数回呼ばれてしまう**。

### 学び・解決アプローチ

#### 1. debounceを「イベントハンドラ内」だけで使うとズレる

- ボタン連打時に**最後の1回だけAPI**を呼ぶには`debounce`を使いたくなるが、ボタンの`onClick`内で`debouncedCallback(currentValue)`としても、その時点のstate（`currentMonthsInView`）は**まだ反映前のもの**。
- その結果、「最後に見えているカレンダーの状態」でAPIが呼ばれない。

#### 2. 正解は「stateの変化を監視し、その変化をdebounce」すること

- **「UIの表示stateが変わったときにAPIリクエストをdebounceで発火する」**のが本質的な解決法。
  - つまり「クリック」は**stateだけを変更**し、**API呼び出しはuseEffectでstateの変化に反応**する。
- `use-debounce` の `useDebouncedCallback` を `useEffect` と組み合わせるとよい。

#### 3. AbortControllerの正しい管理

- 連打時に**古いAPIリクエストをabortする**には、`AbortController`インスタンスを`useRef`で管理し、API呼び出し前に`abort()`してから新しいものに差し替える。
- これにより「リクエスト競合で意図しないデータ上書き」も防げる。

#### 4. 今月ボタンなど「即時API取得」はdebounceを使わず直接呼ぶ

- 今月ボタン押下時だけは`debounce`なしで即時APIリクエストすることで、UIレスポンスの一貫性を担保。

### サンプル実装（重要部分のみ）

```tsx
// カレンダーの月送りボタンによる表示月変更＋API取得のdebounce例

import { useRef, useEffect } from 'react';
import { useSelector } from 'react-redux';
import { useDebouncedCallback } from 'use-debounce';

export const CalendarController = () => {
  // カレンダーで表示する月リスト（例：['2025-07', '2025-08']）
  const displayMonths = useSelector(state => state.calendar.displayMonths);
  // ...他にも必要なstateをuseSelectorで取得...

  const abortRef = useRef<AbortController | null>(null);

  // APIリクエスト本体
  const fetchCalendarData = (months: string[]) => {
    if (abortRef.current) abortRef.current.abort();
    const controller = new AbortController();
    // ここでAPIを呼ぶ。引数: months, controller.signalなど
    // fetch('/api/calendar', { signal: controller.signal, ... })
    abortRef.current = controller;
  };

  // 「月送り」クリック時は表示stateだけ変更（APIは呼ばない）
  const onClickPrev = () => {
    // dispatch({ type: 'PREV_MONTH' })
  };
  const onClickNext = () => {
    // dispatch({ type: 'NEXT_MONTH' })
  };
  // 今月ボタンだけは即時API
  const onClickToday = () => {
    // dispatch({ type: 'RESET_MONTH' })
    fetchCalendarData(['2025-07']); // 例：今月だけ
  };

  // 表示月リストが変わったらdebounceでAPI取得
  const debouncedFetch = useDebouncedCallback(() => {
    if (!displayMonths.length) return;
    fetchCalendarData(displayMonths);
  }, 500);
  useEffect(() => {
    debouncedFetch();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [displayMonths]);

  return (
    <div>
      <button onClick={onClickPrev}>前月</button>
      <button onClick={onClickToday}>今月</button>
      <button onClick={onClickNext}>次月</button>
    </div>
  );
};
```

---

## 2025-07-01: Reduxと非同期処理の厳密な完了検知

### 学び・ポイント

JavaScriptの非同期処理とReduxの状態管理を組み合わせる際の、正確な完了検知パターンについて学習。

#### 1. 並列 vs 直列処理の違い

- **`forEach(async ...)`の落とし穴**: 各ループが並列に非同期処理を実行するため、すべての完了を待つには`Promise.all()`でラップが必要
- **`for...of`と`await`**: 逐次（直列）処理で、各ループ内の非同期処理が完了するまで次のループに進まない
- **パフォーマンス**: 複数のAPIリクエストを同時実行したい場合は`Promise.all(array.map(...))`が最も効率的

#### 2. Reduxでの厳密な完了検知

- **課題**: 非同期処理完了後の最新ストア値を確実に取得したい
- **解決策**: ストア内に「完了フラグ」を状態として持ち、`useSelector`で監視
- **メリット**: レンダリングサイクルに依存しない確実な完了検知

#### 3. ESLintエラー対策

- **問題**: `useEffect`内のasync IIFEで`no-floating-promises`エラー
- **対策**: `try/catch`でエラーハンドリングまたは`void`演算子を使用

### Example/Code

#### 並列処理での完了検知

```ts
// ❌ 問題のあるパターン - 完了検知できない
yearMonths.forEach(async yearMonth => {
  await fetchDataForMonth(yearMonth);
});
// この時点で全てのAPIが完了しているかは不明

// ✅ 正しいパターン - Promise.allで全完了を待つ
const results = await Promise.all(
  yearMonths.map(async yearMonth => {
    const data = await fetchDataForMonth(yearMonth);
    return data;
  })
);
console.log('全てのAPIリクエストが完了');
```

#### 直列処理での完了検知

```ts
// ✅ for...of で逐次処理
for (const yearMonth of yearMonths) {
  await fetchDataForMonth(yearMonth);
  console.log(`${yearMonth}の処理完了`);
}
console.log('全ての処理が順番に完了');
```

#### Reduxでの厳密な完了検知

```ts
// Redux store設計
interface BookingState {
  data: BookingData[];
  isFetching: boolean;
  isFetched: boolean;
  error: string | null;
}

const initialState: BookingState = {
  data: [],
  isFetching: false,
  isFetched: false,
  error: null,
};

// Reducer
function bookingReducer(state = initialState, action: AnyAction): BookingState {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, isFetching: true, isFetched: false, error: null };
    case 'FETCH_SUCCESS':
      return {
        ...state,
        data: action.payload,
        isFetching: false,
        isFetched: true
      };
    case 'FETCH_ERROR':
      return {
        ...state,
        isFetching: false,
        isFetched: false,
        error: action.payload
      };
    default:
      return state;
  }
}

// Component での使用
const BookingComponent: React.FC = () => {
  const { data, isFetching, isFetched } = useSelector((state: RootState) => state.booking);
  const dispatch = useDispatch();

  // 厳密な完了検知
  useEffect(() => {
    if (isFetched) {
      // ここで最新のストア値（data）を安全に使用できる
      console.log('最新データ:', data);
      // 次の処理を実行
      processBookingData(data);
    }
  }, [isFetched, data]);

  const handleFetch = async () => {
    dispatch({ type: 'FETCH_START' });
    try {
      const results = await Promise.all(
        yearMonths.map(yearMonth => fetchBookingData(yearMonth))
      );
      dispatch({ type: 'FETCH_SUCCESS', payload: results.flat() });
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', payload: error.message });
    }
  };

  return (
    <div>
      <button onClick={handleFetch} disabled={isFetching}>
        {isFetching ? 'データ取得中...' : 'データ取得'}
      </button>
      {isFetched && <div>データ取得完了: {data.length}件</div>}
    </div>
  );
};
```

#### useEffect内でのasync処理

```ts
// ❌ ESLintエラーが発生するパターン
useEffect(() => {
  (async () => {
    await fetchData();
  })(); // no-floating-promises エラー
}, []);

// ✅ try/catchでエラーハンドリング
useEffect(() => {
  (async () => {
    try {
      await fetchData();
      console.log('データ取得成功');
    } catch (error) {
      console.error('データ取得エラー:', error);
    }
  })();
}, []);

// ✅ void演算子を使用
useEffect(() => {
  void (async () => {
    await fetchData();
  })();
}, []);

// ✅ 別関数として定義（推奨）
useEffect(() => {
  const fetchDataAsync = async () => {
    try {
      await fetchData();
    } catch (error) {
      console.error(error);
    }
  };

  fetchDataAsync();
}, []);
```

### References

- [Redux公式ドキュメント: Async Logic](https://redux.js.org/tutorials/fundamentals/part-6-async-logic)
- [React公式: useEffectのベストプラクティス](https://react.dev/reference/react/useEffect)

---

<!-- Template for new entries -->
<!--
## 2025-07-XX: [Topic Title]

[Description of what you learned today]

### Example/Code (if applicable)

```txt
# Code example here
```

### References

- [Reference link 1](https://example.com)
- [Reference link 2](https://example.com)
-->
