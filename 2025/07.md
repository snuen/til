# July 2025 TIL (Today I Learned)

This file contains things I learned during July 2025.

---

## 2025-07-01: Reduxと非同期処理の厳密な完了検知

### 学び・ポイント

- `forEach(async ...)`は各ループが「並列」に非同期処理を走らせるため、すべての完了タイミングの検知には`Promise.all([...])`でラップする必要がある。
- 一方、`for...of`と`await`を組み合わせると「逐次（直列）」で処理され、各ループ内の非同期処理が終わるまで次のループに進まない。
- 複数のAPIリクエストを「全部同時に投げて、全部終わったら次の処理に進みたい」場合は`Promise.all(yearMonths.map(...))`パターンが最もシンプルで速い。
- Reduxストアの「最新値」を`useSelector`で取得する場合、非同期処理が全て完了した後にストアへ反映されたことを**厳密に検知**したければ、ストア内に「完了フラグ」をstateとして持たせ、`dispatch`で更新し、`useSelector`で監視するのが安全。
- Reactの`useEffect`内でasync
  IIFEを使う場合、ESLintの`no-floating-promises`エラー対策として`try/catch`でエラー補足するか、`void`演算子を使うこと。

### Example/Code

```ts
// すべてのAPIリクエストの完了をPromise.allで検知
await Promise.all(
  yearMonths.map((yearMonth) => {
    // ...APIリクエスト
    return Promise.all([/* ... */]);
  })
);

// ストアに完了フラグを持たせて厳密な完了検知
const initialState = { ..., isFetched: false };
function reducer(state = initialState, action) {
  switch (action.type) {
    case 'SET_FETCHED': return { ...state, isFetched: true };
    // ...
  }
}
// 監視
const isFetched = useSelector(state => state.booking.isFetched);
useEffect(() => {
  if (isFetched) {
    // ここで最新のストア値を安全に使える
  }
}, [isFetched]);

// useEffect内のasync IIFEでcatchをつけてESLintエラー対策
useEffect(() => {
  (async () => {
    try {
      await fetchData();
      // ...
    } catch (e) {
      console.error(e);
    }
  })();
}, []);
```

### References

- [Redux公式ドキュメント: Async Logic](https://redux.js.org/tutorials/fundamentals/part-6-async-logic)
- [React公式: useEffectのベストプラクティス](https://react.dev/reference/react/useEffect)

---

<!-- Template for new entries -->
<!--
## 2025-07-XX: [Topic Title]

[Description of what you learned today]

### Example/Code (if applicable)

```txt
# Code example here
```

### References

- [Reference link 1](https://example.com)
- [Reference link 2](https://example.com)
-->
