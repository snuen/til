# July 2025 TIL (Today I Learned)

This file contains things I learned during July 2025.

---

## 2025-07-03: ClaudeのProjectsでのAI Driven Developmentの実践

Claudeの機能であるProjectsを使って、AI Driven Developmentの実践可能性を検証してみた。

### Projects機能の概要

Projects配下で、プロジェクト単位でナレッジを改めて紐づけることができるのだが、そのナレッジをClaude側がプロジェクト内のチャットで毎回参照してくれるというものらしい。

#### 基本構成要素

- **プロジェクト設定**: プロジェクト名と簡単な説明
- **プロジェクトナレッジ**: プロジェクトの目的、技術スタック、関連するドキュメント、開発ルール等
- **コンテキスト継承**: プロジェクト内のチャットで、登録されたナレッジを自動的に参照して回答

### 実践例: Reactカレンダーアプリ

プロジェクト名が「Reactカレンダーアプリ」で、目的が「ユーザーがカレンダーを操作できるUIを提供する」場合の設定例:

#### プロジェクトナレッジ設定

- **目的**: ユーザーがカレンダーを操作できるUIを提供する
- **技術スタック**: React, Redux, TypeScript
- **関連ドキュメント**:
  - [React公式ドキュメント](https://react.dev/)
  - [Redux公式ドキュメント](https://redux.js.org/)
- **プロジェクトのルール**: コードはESLintでチェックし、Prettierでフォーマットする
- **開発環境**: Node.js 20以上
- **API仕様**: カレンダーのデータはREST APIで取得し、JSON形式で返す
- **テストフレームワーク**: JestとReact Testing Libraryを使用
- **デプロイ方法**: Vercelを使用してデプロイする
- **CI/CD**: GitHub Actionsを使用して、プルリクエスト時に自動テストとデプロイを行う

#### 実際の会話例

**質問**: 「カレンダーコンポーネントで月の切り替えを実装したい」

**Claude回答（プロジェクトナレッジ参照）**:
Redux状態管理を使用して、月の切り替えを実装しましょう。TypeScriptでの型安全性を確保し、ESLint/Prettierルールに従って実装します。

### AI Driven Developmentの効果検証

#### メリット

1. **コンテキスト継続性**: プロジェクト固有の制約や方針を毎回説明する必要がない
2. **一貫性確保**: 技術スタックや開発ルールが自動的に適用される
3. **効率化**: 過去の決定事項や設計方針を再利用できる
4. **知識の構造化**: プロジェクト知識が体系的に整理される

#### 注意点・制約

1. **初期設定の重要性**: ナレッジ設定の品質が回答品質に直結
2. **更新の必要性**: プロジェクトの進化に伴うナレッジの更新が必要
3. **複雑性の管理**: 大規模プロジェクトでは情報量が膨大になる可能性

### 効果的なナレッジ構成のベストプラクティス

#### 1. 階層的な情報構造

```
プロジェクト概要
├── 技術仕様
│   ├── 技術スタック
│   ├── アーキテクチャ
│   └── 開発環境
├── 開発ルール
│   ├── コーディング規約
│   ├── テスト方針
│   └── デプロイ手順
└── 参考資料
    ├── 外部ドキュメント
    ├── 設計決定記録
    └── トラブルシューティング
```

#### 2. コンテキストの粒度調整

- **Too Fine**: 詳細すぎる実装レベルの情報
- **Too Coarse**: 抽象的すぎる概念レベルの情報
- **Just Right**: 開発判断に必要な適切な抽象化レベル

#### 3. 進化的な知識管理

- プロジェクト進行に合わせた段階的な知識追加
- 過去の決定事項の記録と更新
- 失敗事例や制約事項の明文化

### 開発フローへの統合

#### 従来の開発フロー

```
要件定義 → 設計 → 実装 → テスト → デプロイ
```

#### AI Driven Development with Projects

```
要件定義 → ナレッジ設定 → AI協調設計 → AI支援実装 → AI検証テスト → デプロイ
```

各段階でProjectsナレッジを活用することで、一貫性のある開発が可能となる。

### 今後の展望

- **チーム開発**: 複数開発者間でのナレッジ共有
- **継続的改善**: 開発過程での知識蓄積とフィードバック
- **自動化**: CI/CDパイプラインとの統合可能性

### 実践的なナレッジ設定テンプレート

#### プロジェクト設定JSON例

```json
{
  "project": {
    "name": "React Calendar App",
    "description": "Interactive calendar UI with Redux state management",
    "tech_stack": ["React", "Redux", "TypeScript", "Vite"],
    "architecture": "Component-based SPA",
    "development_rules": {
      "linting": "ESLint + Prettier",
      "testing": "Jest + React Testing Library",
      "state_management": "Redux Toolkit",
      "styling": "CSS Modules + Tailwind CSS"
    },
    "api_specification": {
      "base_url": "https://api.calendar.example.com",
      "endpoints": {
        "calendar_data": "GET /api/calendar/:year/:month",
        "events": "GET /api/events",
        "create_event": "POST /api/events"
      },
      "authentication": "Bearer token"
    },
    "deployment": {
      "platform": "Vercel",
      "environment_variables": ["VITE_API_BASE_URL", "VITE_API_KEY"],
      "build_command": "npm run build",
      "preview_command": "npm run preview"
    }
  }
}
```

#### 開発ワークフロー例

```typescript
// AI支援開発での典型的なやり取り

// 1. 要件確認
"新しいイベント作成機能を追加したい"

// 2. AI応答（プロジェクトナレッジ参照）
"Redux Toolkitを使用してイベント作成機能を実装しましょう。
TypeScriptでの型安全性を確保し、React Testing Libraryでテストも含めます。"

// 3. 実装提案
interface CreateEventPayload {
  title: string;
  date: string;
  description?: string;
}

const createEventSlice = createSlice({
  name: 'events',
  initialState: {
    events: [] as Event[],
    loading: false,
    error: null
  },
  reducers: {
    createEventStart: (state) => {
      state.loading = true;
    },
    createEventSuccess: (state, action) => {
      state.events.push(action.payload);
      state.loading = false;
    },
    createEventFailure: (state, action) => {
      state.error = action.payload;
      state.loading = false;
    }
  }
});
```

### References

- [Claude Projects Documentation](https://support.anthropic.com/en/articles/9517075-what-are-projects)
- [AI-Driven Development Best Practices](https://www.anthropic.com/news/claude-3-family)

---

## 2025-07-02: Reactでのカレンダー操作とAPIリクエスト最適化の学び

### 課題

- カレンダーUIで「前月」「次月」ボタンを連打すると、不要なAPIリクエストが大量に発生する。
- クリック直後の状態はまだ反映されていない（`useSelector`で取得しているstateは、reducer適用の1フレーム後にしか変わらない）ため、連打時に**最終表示状態ではなく“途中の状態”でAPIが複数回呼ばれてしまう**。

### 学び・解決アプローチ

#### 1. debounceを「イベントハンドラ内」だけで使うとズレる

- ボタン連打時に**最後の1回だけAPI**を呼ぶには`debounce`を使いたくなるが、ボタンの`onClick`内で`debouncedCallback(currentValue)`としても、その時点のstate（`currentMonthsInView`）は**まだ反映前のもの**。
- その結果、「最後に見えているカレンダーの状態」でAPIが呼ばれない。

#### 2. 正解は「stateの変化を監視し、その変化をdebounce」すること

- **「UIの表示stateが変わったときにAPIリクエストをdebounceで発火する」**のが本質的な解決法。
  - つまり「クリック」は**stateだけを変更**し、**API呼び出しはuseEffectでstateの変化に反応**する。
- `use-debounce` の `useDebouncedCallback` を `useEffect` と組み合わせるとよい。

#### 3. AbortControllerの正しい管理

- 連打時に**古いAPIリクエストをabortする**には、`AbortController`インスタンスを`useRef`で管理し、API呼び出し前に`abort()`してから新しいものに差し替える。
- これにより「リクエスト競合で意図しないデータ上書き」も防げる。

#### 4. 今月ボタンなど「即時API取得」はdebounceを使わず直接呼ぶ

- 今月ボタン押下時だけは`debounce`なしで即時APIリクエストすることで、UIレスポンスの一貫性を担保。

### サンプル実装（重要部分のみ）

```tsx
// カレンダーの月送りボタンによる表示月変更＋API取得のdebounce例

import { useRef, useEffect } from 'react';
import { useSelector } from 'react-redux';
import { useDebouncedCallback } from 'use-debounce';

export const CalendarController = () => {
  // カレンダーで表示する月リスト（例：['2025-07', '2025-08']）
  const displayMonths = useSelector(state => state.calendar.displayMonths);
  // ...他にも必要なstateをuseSelectorで取得...

  const abortRef = useRef<AbortController | null>(null);

  // APIリクエスト本体
  const fetchCalendarData = (months: string[]) => {
    if (abortRef.current) abortRef.current.abort();
    const controller = new AbortController();
    // ここでAPIを呼ぶ。引数: months, controller.signalなど
    // fetch('/api/calendar', { signal: controller.signal, ... })
    abortRef.current = controller;
  };

  // 「月送り」クリック時は表示stateだけ変更（APIは呼ばない）
  const onClickPrev = () => {
    // dispatch({ type: 'PREV_MONTH' })
  };
  const onClickNext = () => {
    // dispatch({ type: 'NEXT_MONTH' })
  };
  // 今月ボタンだけは即時API
  const onClickToday = () => {
    // dispatch({ type: 'RESET_MONTH' })
    fetchCalendarData(['2025-07']); // 例：今月だけ
  };

  // 表示月リストが変わったらdebounceでAPI取得
  const debouncedFetch = useDebouncedCallback(() => {
    if (!displayMonths.length) return;
    fetchCalendarData(displayMonths);
  }, 500);
  useEffect(() => {
    debouncedFetch();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [displayMonths]);

  return (
    <div>
      <button onClick={onClickPrev}>前月</button>
      <button onClick={onClickToday}>今月</button>
      <button onClick={onClickNext}>次月</button>
    </div>
  );
};
```

---

## 2025-07-01: Reduxと非同期処理の厳密な完了検知

### 学び・ポイント

JavaScriptの非同期処理とReduxの状態管理を組み合わせる際の、正確な完了検知パターンについて学習。

#### 1. 並列 vs 直列処理の違い

- **`forEach(async ...)`の落とし穴**: 各ループが並列に非同期処理を実行するため、すべての完了を待つには`Promise.all()`でラップが必要
- **`for...of`と`await`**: 逐次（直列）処理で、各ループ内の非同期処理が完了するまで次のループに進まない
- **パフォーマンス**: 複数のAPIリクエストを同時実行したい場合は`Promise.all(array.map(...))`が最も効率的

#### 2. Reduxでの厳密な完了検知

- **課題**: 非同期処理完了後の最新ストア値を確実に取得したい
- **解決策**: ストア内に「完了フラグ」を状態として持ち、`useSelector`で監視
- **メリット**: レンダリングサイクルに依存しない確実な完了検知

#### 3. ESLintエラー対策

- **問題**: `useEffect`内のasync IIFEで`no-floating-promises`エラー
- **対策**: `try/catch`でエラーハンドリングまたは`void`演算子を使用

### Example/Code

#### 並列処理での完了検知

```ts
// ❌ 問題のあるパターン - 完了検知できない
yearMonths.forEach(async yearMonth => {
  await fetchDataForMonth(yearMonth);
});
// この時点で全てのAPIが完了しているかは不明

// ✅ 正しいパターン - Promise.allで全完了を待つ
const results = await Promise.all(
  yearMonths.map(async yearMonth => {
    const data = await fetchDataForMonth(yearMonth);
    return data;
  })
);
console.log('全てのAPIリクエストが完了');
```

#### 直列処理での完了検知

```ts
// ✅ for...of で逐次処理
for (const yearMonth of yearMonths) {
  await fetchDataForMonth(yearMonth);
  console.log(`${yearMonth}の処理完了`);
}
console.log('全ての処理が順番に完了');
```

#### Reduxでの厳密な完了検知

```ts
// Redux store設計
interface BookingState {
  data: BookingData[];
  isFetching: boolean;
  isFetched: boolean;
  error: string | null;
}

const initialState: BookingState = {
  data: [],
  isFetching: false,
  isFetched: false,
  error: null,
};

// Reducer
function bookingReducer(state = initialState, action: AnyAction): BookingState {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, isFetching: true, isFetched: false, error: null };
    case 'FETCH_SUCCESS':
      return {
        ...state,
        data: action.payload,
        isFetching: false,
        isFetched: true
      };
    case 'FETCH_ERROR':
      return {
        ...state,
        isFetching: false,
        isFetched: false,
        error: action.payload
      };
    default:
      return state;
  }
}

// Component での使用
const BookingComponent: React.FC = () => {
  const { data, isFetching, isFetched } = useSelector((state: RootState) => state.booking);
  const dispatch = useDispatch();

  // 厳密な完了検知
  useEffect(() => {
    if (isFetched) {
      // ここで最新のストア値（data）を安全に使用できる
      console.log('最新データ:', data);
      // 次の処理を実行
      processBookingData(data);
    }
  }, [isFetched, data]);

  const handleFetch = async () => {
    dispatch({ type: 'FETCH_START' });
    try {
      const results = await Promise.all(
        yearMonths.map(yearMonth => fetchBookingData(yearMonth))
      );
      dispatch({ type: 'FETCH_SUCCESS', payload: results.flat() });
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', payload: error.message });
    }
  };

  return (
    <div>
      <button onClick={handleFetch} disabled={isFetching}>
        {isFetching ? 'データ取得中...' : 'データ取得'}
      </button>
      {isFetched && <div>データ取得完了: {data.length}件</div>}
    </div>
  );
};
```

#### useEffect内でのasync処理

```ts
// ❌ ESLintエラーが発生するパターン
useEffect(() => {
  (async () => {
    await fetchData();
  })(); // no-floating-promises エラー
}, []);

// ✅ try/catchでエラーハンドリング
useEffect(() => {
  (async () => {
    try {
      await fetchData();
      console.log('データ取得成功');
    } catch (error) {
      console.error('データ取得エラー:', error);
    }
  })();
}, []);

// ✅ void演算子を使用
useEffect(() => {
  void (async () => {
    await fetchData();
  })();
}, []);

// ✅ 別関数として定義（推奨）
useEffect(() => {
  const fetchDataAsync = async () => {
    try {
      await fetchData();
    } catch (error) {
      console.error(error);
    }
  };

  fetchDataAsync();
}, []);
```

### References

- [Redux公式ドキュメント: Async Logic](https://redux.js.org/tutorials/fundamentals/part-6-async-logic)
- [React公式: useEffectのベストプラクティス](https://react.dev/reference/react/useEffect)

---

<!-- Template for new entries -->
<!--
## 2025-07-XX: [Topic Title]

[Description of what you learned today]

### Example/Code (if applicable)

```txt
# Code example here
```

### References

- [Reference link 1](https://example.com)
- [Reference link 2](https://example.com)
-->
