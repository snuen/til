# July 2025 TIL (Today I Learned)

This file contains things I learned during July 2025.

---

## 2025-07-01: Reduxと非同期処理の厳密な完了検知

### 学び・ポイント

JavaScriptの非同期処理とReduxの状態管理を組み合わせる際の、正確な完了検知パターンについて学習。

#### 1. 並列 vs 直列処理の違い

- **`forEach(async ...)`の落とし穴**: 各ループが並列に非同期処理を実行するため、すべての完了を待つには`Promise.all()`でラップが必要
- **`for...of`と`await`**: 逐次（直列）処理で、各ループ内の非同期処理が完了するまで次のループに進まない
- **パフォーマンス**: 複数のAPIリクエストを同時実行したい場合は`Promise.all(array.map(...))`が最も効率的

#### 2. Reduxでの厳密な完了検知

- **課題**: 非同期処理完了後の最新ストア値を確実に取得したい
- **解決策**: ストア内に「完了フラグ」を状態として持ち、`useSelector`で監視
- **メリット**: レンダリングサイクルに依存しない確実な完了検知

#### 3. ESLintエラー対策

- **問題**: `useEffect`内のasync IIFEで`no-floating-promises`エラー
- **対策**: `try/catch`でエラーハンドリングまたは`void`演算子を使用

### Example/Code

#### 並列処理での完了検知

```ts
// ❌ 問題のあるパターン - 完了検知できない
yearMonths.forEach(async yearMonth => {
  await fetchDataForMonth(yearMonth);
});
// この時点で全てのAPIが完了しているかは不明

// ✅ 正しいパターン - Promise.allで全完了を待つ
const results = await Promise.all(
  yearMonths.map(async yearMonth => {
    const data = await fetchDataForMonth(yearMonth);
    return data;
  })
);
console.log('全てのAPIリクエストが完了');
```

#### 直列処理での完了検知

```ts
// ✅ for...of で逐次処理
for (const yearMonth of yearMonths) {
  await fetchDataForMonth(yearMonth);
  console.log(`${yearMonth}の処理完了`);
}
console.log('全ての処理が順番に完了');
```

#### Reduxでの厳密な完了検知

```ts
// Redux store設計
interface BookingState {
  data: BookingData[];
  isFetching: boolean;
  isFetched: boolean;
  error: string | null;
}

const initialState: BookingState = {
  data: [],
  isFetching: false,
  isFetched: false,
  error: null,
};

// Reducer
function bookingReducer(state = initialState, action: AnyAction): BookingState {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, isFetching: true, isFetched: false, error: null };
    case 'FETCH_SUCCESS':
      return {
        ...state,
        data: action.payload,
        isFetching: false,
        isFetched: true
      };
    case 'FETCH_ERROR':
      return {
        ...state,
        isFetching: false,
        isFetched: false,
        error: action.payload
      };
    default:
      return state;
  }
}

// Component での使用
const BookingComponent: React.FC = () => {
  const { data, isFetching, isFetched } = useSelector((state: RootState) => state.booking);
  const dispatch = useDispatch();

  // 厳密な完了検知
  useEffect(() => {
    if (isFetched) {
      // ここで最新のストア値（data）を安全に使用できる
      console.log('最新データ:', data);
      // 次の処理を実行
      processBookingData(data);
    }
  }, [isFetched, data]);

  const handleFetch = async () => {
    dispatch({ type: 'FETCH_START' });
    try {
      const results = await Promise.all(
        yearMonths.map(yearMonth => fetchBookingData(yearMonth))
      );
      dispatch({ type: 'FETCH_SUCCESS', payload: results.flat() });
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', payload: error.message });
    }
  };

  return (
    <div>
      <button onClick={handleFetch} disabled={isFetching}>
        {isFetching ? 'データ取得中...' : 'データ取得'}
      </button>
      {isFetched && <div>データ取得完了: {data.length}件</div>}
    </div>
  );
};
```

#### useEffect内でのasync処理

```ts
// ❌ ESLintエラーが発生するパターン
useEffect(() => {
  (async () => {
    await fetchData();
  })(); // no-floating-promises エラー
}, []);

// ✅ try/catchでエラーハンドリング
useEffect(() => {
  (async () => {
    try {
      await fetchData();
      console.log('データ取得成功');
    } catch (error) {
      console.error('データ取得エラー:', error);
    }
  })();
}, []);

// ✅ void演算子を使用
useEffect(() => {
  void (async () => {
    await fetchData();
  })();
}, []);

// ✅ 別関数として定義（推奨）
useEffect(() => {
  const fetchDataAsync = async () => {
    try {
      await fetchData();
    } catch (error) {
      console.error(error);
    }
  };

  fetchDataAsync();
}, []);
```

### References

- [Redux公式ドキュメント: Async Logic](https://redux.js.org/tutorials/fundamentals/part-6-async-logic)
- [React公式: useEffectのベストプラクティス](https://react.dev/reference/react/useEffect)

---

<!-- Template for new entries -->
<!--
## 2025-07-XX: [Topic Title]

[Description of what you learned today]

### Example/Code (if applicable)

```txt
# Code example here
```

### References

- [Reference link 1](https://example.com)
- [Reference link 2](https://example.com)
-->
