# July 2025 TIL (Today I Learned)

This file contains things I learned during July 2025.

---

## 2025-07-03: ClaudeのProjectsでのAI Driven Developmentの実践

Claudeの機能であるProjectsを使って、AI Driven Developmentとやらができるか試してみた。

Projects配下で、プロジェクト単位でナレッジを改めて紐づけることができるのだが、そのナレッジをClaude側がプロジェクト内のチャットで毎回参照してくれるというものらしい。

どう使うかはプロジェクトの内容次第だが、例えば以下のような使い方ができそうだ。

前提として、

- プロジェクトの内容は、プロジェクト名と簡単な説明
- プロジェクトに紐づくナレッジは、プロジェクトの目的や技術スタック、関連するドキュメントなど
- プロジェクト内のチャットは、プロジェクトに紐づくナレッジを参照して回答する

がある。

実例を挙げてみると、

プロジェクト名が「Reactカレンダーアプリ」で、目的が「ユーザーがカレンダーを操作できるUIを提供する」場合、以下のようなナレッジを登録しておく。

- **目的**: ユーザーがカレンダーを操作できるUIを提供する
- **技術スタック**: React, Redux, TypeScript
- **関連ドキュメント**: [React公式ドキュメント](https://reactjs.org/docs/getting-started.html),
  [Redux公式ドキュメント](https:// redux.js.org/introduction/getting-started)
- **プロジェクトのルール**: コードはESLintでチェックし、Prettierでフォーマットする
- **開発環境**: Node.js 20以上
- **API仕様**: カレンダーのデータはREST APIで取得し、JSON形式で返す
- **テストフレームワーク**: JestとReact Testing Libraryを使用
- **デプロイ方法**: Vercelを使用してデプロイする
- **CI/CD**: GitHub Actionsを使用して、プルリクエスト時に自動テストとデプロイを行う

みたいな具合で、プロジェクトに関するナレッジを登録しておき、プロジェクト内のチャットで質問すると、Claudeはそのナレッジを参照して回答してくれる。

---

## 2025-07-02: Reactでのカレンダー操作とAPIリクエスト最適化の学び

### 課題

- カレンダーUIで「前月」「次月」ボタンを連打すると、不要なAPIリクエストが大量に発生する。
- クリック直後の状態はまだ反映されていない（`useSelector`で取得しているstateは、reducer適用の1フレーム後にしか変わらない）ため、連打時に**最終表示状態ではなく“途中の状態”でAPIが複数回呼ばれてしまう**。

### 学び・解決アプローチ

#### 1. debounceを「イベントハンドラ内」だけで使うとズレる

- ボタン連打時に**最後の1回だけAPI**を呼ぶには`debounce`を使いたくなるが、ボタンの`onClick`内で`debouncedCallback(currentValue)`としても、その時点のstate（`currentMonthsInView`）は**まだ反映前のもの**。
- その結果、「最後に見えているカレンダーの状態」でAPIが呼ばれない。

#### 2. 正解は「stateの変化を監視し、その変化をdebounce」すること

- **「UIの表示stateが変わったときにAPIリクエストをdebounceで発火する」**のが本質的な解決法。
  - つまり「クリック」は**stateだけを変更**し、**API呼び出しはuseEffectでstateの変化に反応**する。
- `use-debounce` の `useDebouncedCallback` を `useEffect` と組み合わせるとよい。

#### 3. AbortControllerの正しい管理

- 連打時に**古いAPIリクエストをabortする**には、`AbortController`インスタンスを`useRef`で管理し、API呼び出し前に`abort()`してから新しいものに差し替える。
- これにより「リクエスト競合で意図しないデータ上書き」も防げる。

#### 4. 今月ボタンなど「即時API取得」はdebounceを使わず直接呼ぶ

- 今月ボタン押下時だけは`debounce`なしで即時APIリクエストすることで、UIレスポンスの一貫性を担保。

### サンプル実装（重要部分のみ）

```tsx
// カレンダーの月送りボタンによる表示月変更＋API取得のdebounce例

import { useRef, useEffect } from 'react';
import { useSelector } from 'react-redux';
import { useDebouncedCallback } from 'use-debounce';

export const CalendarController = () => {
  // カレンダーで表示する月リスト（例：['2025-07', '2025-08']）
  const displayMonths = useSelector(state => state.calendar.displayMonths);
  // ...他にも必要なstateをuseSelectorで取得...

  const abortRef = useRef<AbortController | null>(null);

  // APIリクエスト本体
  const fetchCalendarData = (months: string[]) => {
    if (abortRef.current) abortRef.current.abort();
    const controller = new AbortController();
    // ここでAPIを呼ぶ。引数: months, controller.signalなど
    // fetch('/api/calendar', { signal: controller.signal, ... })
    abortRef.current = controller;
  };

  // 「月送り」クリック時は表示stateだけ変更（APIは呼ばない）
  const onClickPrev = () => {
    // dispatch({ type: 'PREV_MONTH' })
  };
  const onClickNext = () => {
    // dispatch({ type: 'NEXT_MONTH' })
  };
  // 今月ボタンだけは即時API
  const onClickToday = () => {
    // dispatch({ type: 'RESET_MONTH' })
    fetchCalendarData(['2025-07']); // 例：今月だけ
  };

  // 表示月リストが変わったらdebounceでAPI取得
  const debouncedFetch = useDebouncedCallback(() => {
    if (!displayMonths.length) return;
    fetchCalendarData(displayMonths);
  }, 500);
  useEffect(() => {
    debouncedFetch();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [displayMonths]);

  return (
    <div>
      <button onClick={onClickPrev}>前月</button>
      <button onClick={onClickToday}>今月</button>
      <button onClick={onClickNext}>次月</button>
    </div>
  );
};
```

---

## 2025-07-01: Reduxと非同期処理の厳密な完了検知

### 学び・ポイント

JavaScriptの非同期処理とReduxの状態管理を組み合わせる際の、正確な完了検知パターンについて学習。

#### 1. 並列 vs 直列処理の違い

- **`forEach(async ...)`の落とし穴**: 各ループが並列に非同期処理を実行するため、すべての完了を待つには`Promise.all()`でラップが必要
- **`for...of`と`await`**: 逐次（直列）処理で、各ループ内の非同期処理が完了するまで次のループに進まない
- **パフォーマンス**: 複数のAPIリクエストを同時実行したい場合は`Promise.all(array.map(...))`が最も効率的

#### 2. Reduxでの厳密な完了検知

- **課題**: 非同期処理完了後の最新ストア値を確実に取得したい
- **解決策**: ストア内に「完了フラグ」を状態として持ち、`useSelector`で監視
- **メリット**: レンダリングサイクルに依存しない確実な完了検知

#### 3. ESLintエラー対策

- **問題**: `useEffect`内のasync IIFEで`no-floating-promises`エラー
- **対策**: `try/catch`でエラーハンドリングまたは`void`演算子を使用

### Example/Code

#### 並列処理での完了検知

```ts
// ❌ 問題のあるパターン - 完了検知できない
yearMonths.forEach(async yearMonth => {
  await fetchDataForMonth(yearMonth);
});
// この時点で全てのAPIが完了しているかは不明

// ✅ 正しいパターン - Promise.allで全完了を待つ
const results = await Promise.all(
  yearMonths.map(async yearMonth => {
    const data = await fetchDataForMonth(yearMonth);
    return data;
  })
);
console.log('全てのAPIリクエストが完了');
```

#### 直列処理での完了検知

```ts
// ✅ for...of で逐次処理
for (const yearMonth of yearMonths) {
  await fetchDataForMonth(yearMonth);
  console.log(`${yearMonth}の処理完了`);
}
console.log('全ての処理が順番に完了');
```

#### Reduxでの厳密な完了検知

```ts
// Redux store設計
interface BookingState {
  data: BookingData[];
  isFetching: boolean;
  isFetched: boolean;
  error: string | null;
}

const initialState: BookingState = {
  data: [],
  isFetching: false,
  isFetched: false,
  error: null,
};

// Reducer
function bookingReducer(state = initialState, action: AnyAction): BookingState {
  switch (action.type) {
    case 'FETCH_START':
      return { ...state, isFetching: true, isFetched: false, error: null };
    case 'FETCH_SUCCESS':
      return {
        ...state,
        data: action.payload,
        isFetching: false,
        isFetched: true
      };
    case 'FETCH_ERROR':
      return {
        ...state,
        isFetching: false,
        isFetched: false,
        error: action.payload
      };
    default:
      return state;
  }
}

// Component での使用
const BookingComponent: React.FC = () => {
  const { data, isFetching, isFetched } = useSelector((state: RootState) => state.booking);
  const dispatch = useDispatch();

  // 厳密な完了検知
  useEffect(() => {
    if (isFetched) {
      // ここで最新のストア値（data）を安全に使用できる
      console.log('最新データ:', data);
      // 次の処理を実行
      processBookingData(data);
    }
  }, [isFetched, data]);

  const handleFetch = async () => {
    dispatch({ type: 'FETCH_START' });
    try {
      const results = await Promise.all(
        yearMonths.map(yearMonth => fetchBookingData(yearMonth))
      );
      dispatch({ type: 'FETCH_SUCCESS', payload: results.flat() });
    } catch (error) {
      dispatch({ type: 'FETCH_ERROR', payload: error.message });
    }
  };

  return (
    <div>
      <button onClick={handleFetch} disabled={isFetching}>
        {isFetching ? 'データ取得中...' : 'データ取得'}
      </button>
      {isFetched && <div>データ取得完了: {data.length}件</div>}
    </div>
  );
};
```

#### useEffect内でのasync処理

```ts
// ❌ ESLintエラーが発生するパターン
useEffect(() => {
  (async () => {
    await fetchData();
  })(); // no-floating-promises エラー
}, []);

// ✅ try/catchでエラーハンドリング
useEffect(() => {
  (async () => {
    try {
      await fetchData();
      console.log('データ取得成功');
    } catch (error) {
      console.error('データ取得エラー:', error);
    }
  })();
}, []);

// ✅ void演算子を使用
useEffect(() => {
  void (async () => {
    await fetchData();
  })();
}, []);

// ✅ 別関数として定義（推奨）
useEffect(() => {
  const fetchDataAsync = async () => {
    try {
      await fetchData();
    } catch (error) {
      console.error(error);
    }
  };

  fetchDataAsync();
}, []);
```

### References

- [Redux公式ドキュメント: Async Logic](https://redux.js.org/tutorials/fundamentals/part-6-async-logic)
- [React公式: useEffectのベストプラクティス](https://react.dev/reference/react/useEffect)

---

<!-- Template for new entries -->
<!--
## 2025-07-XX: [Topic Title]

[Description of what you learned today]

### Example/Code (if applicable)

```txt
# Code example here
```

### References

- [Reference link 1](https://example.com)
- [Reference link 2](https://example.com)
-->
