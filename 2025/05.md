# May 2025 TIL (Today I Learned)

This file contains things I learned during May 2025.

---

## 2025-05-19: コンテナ化しているリポジトリでOrbStackを試す

[OrbStack](https://orbstack.dev/)は、Docker Desktopの代替として、macOS上でコンテナを実行するための軽量なソリューション。

Docker CLIと互換性があり、Docker Composeもサポートしている。

Dockerライセンスによる制限（商用利用の場合、チームライセンスの契約が必要）を回避でき、Apple
Siliconにも最適化されている。

そして何より、Docker Desktopよりも軽量で、起動が速い。

### 参考

- [Docker一強の終焉にあたり、押さえるべきContainer事情](https://zenn.dev/ttnt_1013/articles/f36e251a0cd24e)
- [Docker Desktop と代替ツールの機能検証まとめ](https://zenn.dev/cloud_ace/articles/docker-desktop-verification)

---

## 2025-05-18: 本リポジトリにBunとHonoを導入

本リポジトリを近いうちにAPIサーバーとして動かせればと思い、BunとHonoを導入した。以下に概要をまとめる。

### Bunとは

[Bun](https://bun.sh/)は、JavaScriptとTypeScript向けの新しいランタイムで、Node.jsやDenoの代替として注目されている。

実行環境だけでなく、パッケージマネージャーやビルドツールも兼ね備え、特にパフォーマンスと開発者体験を重視している。

独自エンジンにより高速な実行が可能で、ESモジュール・CommonJS両対応、Node.js APIやパッケージも利用できる。

### Honoとは

[Hono](https://hono.dev/)は、BunやDeno、Cloudflare Workersなどの新しいJavaScriptランタイム向けの軽量Webフレームワーク。

ExpressやKoaに似たAPIを持ちつつ、BunやDenoの特性を活かした高パフォーマンスと開発体験を提供する。

軽量・高速で、特にサーバーレスやエッジ環境に適している。

---

## 2025-05-17: RTK QueryとThunkの使い分け

### Reduxと副作用

[Side Effects Approaches](https://redux.js.org/usage/side-effects-approaches)にあるように、RTK
QueryとThunkは、Reduxにおいて非同期処理を扱うための2つの異なるアプローチである。

Redux storeは非同期ロジックについては何も知らず、同期的に状態を更新することしか知らない。

あらゆる非同期処理は、Redux storeの外部で行われる。

Redux reducersは、副作用を持ってはいけない。

> A "side effect" is any change to state or behavior that can be seen outside of returning a value from a function.

副作用の一例：

- コンソールにログを出力する
- ファイルの保存を行う
- 非同期タイマーをセットする
- AJAX HTTPリクエストを行う
- 乱数やUUIDを生成する（例えば、`Math.random()` or `Date.now()`）

### 推奨アプローチ

- データフェッチとキャッシュに関しては、RTK Queryを使う。
- 「副作用を含む任意の複雑な処理」「API通信以外のasync処理」「複数sliceをまたぐような特殊処理」には、Thunkを使う。
- ActionsやStateの変更へのリアクション、非同期ワークフローには、RTK listenersを使う。

### 参考

- [Redux - Side Effects Approaches](https://redux.js.org/usage/side-effects-approaches)

---

## 2025-05-16: Redux Style Guide

昔からRedux依存しているプロダクトに関わっていると、ついつい見逃しがちだが、[Redux Style Guide](https://redux.js.org/style-guide/)というのがある。

基本はunopinionatedだけど、ライブラリ開発側が「今までの開発経験上こうした方がよい」というのをまとめたスタイルガイドになっている。

ここに書かれたルールを手広く網羅したコードを以下に貼っておく。

Priority B Rule: Structure Files as Feature Folders with Single-File Logic

`src/features/todos/todos-slice.ts`:

```ts
// Priority A Rule: Do not mutate state directly (but Immer in createSlice makes this safe!)
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';

/**
 * Selectors
 */

type RootState = { todos: TodosState };

// Priority C Rule: Use Selector Functions to Read from Store State
// Priority C Rule: Name Selector Functions as selectThing
export const selectTodos = (state: RootState) => state.todos.items;
export const selectCompletedTodos = (state: RootState) => state.todos.items.filter(t => t.completed);

/**
 * Thunks
 */

// Priority C Rule: Use Thunks and Listeners for Other Async Logic
export const fetchTodos = createAsyncThunk<Todo[]>('todos/fetchTodos', async () => {
  const response = await fetch('/api/todos');
  return await response.json();
});

interface Todo {
  id: number;
  text: string;
  completed: boolean;
  createdAt: string;
}

interface TodosState {
  items: Todo[];
  entities: { [id: string]: Todo };
  ids: string[];
  selectedId?: string;
}

const initialState: TodosState = {
  items: [],
  entities: {},
  ids: [],
  selectedId: undefined,
};

const todosSlice = createSlice({
  // Priority C Rule: Write Action Types as `domain/eventName`
  name: 'todos',
  initialState,
  reducers: {
    // Priority B Rule: Model Actions as Events, Not Setters
    // Actionはイベントとしてモデル化し、具体的な名前にする
    // Priority B Rule: Use Immer for Writing Immutable Updates
    // Immerにより「state.items.push」も安全
    // Priority B Rule: Put as Much Logic as Possible in Reducers
    // Reducerにロジックを集約する
    addTodo(state, action: PayloadAction<string>) {
      state.items.push({
        id: Date.now(),
        text: action.payload,
        completed: false,
        // Priority A Rule: Do Not Put Non-Serializable Values in State or Actions
        createdAt: new Date().toISOString(),
      });
    },
    // Priority B Rule: Treat Reducers as State Machines
    // Reducerは状態遷移を表すものとして扱う
    toggleTodo(state, action: PayloadAction<number>) {
      const todo = state.items.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    removeTodo(state, action: PayloadAction<number>) {
      state.items = state.items.filter(t => t.id !== action.payload);
    },
    addAndSelectTodo: {
      // Priority B Rule: Avoid Dispatching Many Actions Sequentially
      reducer(state, action: PayloadAction<{ id: string; text: string }>) {
        state.entities[action.payload.id] = {
          id: action.payload.id,
          text: action.payload.text,
          completed: false,
          createdAt: new Date().toISOString(),
        };
        state.ids.push(action.payload.id);
        state.selectedId = action.payload.id;
      },
      prepare(text: string) {
        const id =
          typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
            ? crypto.randomUUID()
            : Math.random().toString(36).slice(2);
        return { payload: { id, text } };
      },
    },
  },
  extraReducers: builder => {
    builder.addCase(fetchTodos.fulfilled, (state, action) => {
      state.items = action.payload;
    });
  },
});

export const { addTodo, toggleTodo, removeTodo } = todosSlice.actions;
export default todosSlice.reducer;
```

`src/features/todos/todo.tsx`:

```tsx
// Priority C Rule: Use the React-Redux Hooks API
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { selectTodos, addTodo, toggleTodo, removeTodo } from './todosSlice';

export const TodoList: React.FC = () => {
  const todos = useSelector(selectTodos);
  const dispatch = useDispatch();

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          <input type="checkbox" checked={todo.completed} onChange={() => dispatch(toggleTodo(todo.id))} />
          {todo.text}
          <button onClick={() => dispatch(removeTodo(todo.id))}>Delete</button>
        </li>
      ))}
    </ul>
  );
};
```

---

## 2025-05-15: どのリポジトリでも転用が効くと思うPRテンプレート

大体以下で必要十分なのではないかと思う。

```md
## 概要

<!-- 目的・背景 -->

## 内容

<!-- 主な修正点 -->

## 影響

<!-- 影響範囲や注意点 -->

## テスト

<!-- 動作確認やテスト内容 -->

## 関連

<!-- Issueや参考リンク等 -->
```

---

## 2025-05-14: 最近気になっているガジェット

[Tern Setups](https://ternsetups.com/)

モニタとスタンドが一体となっていて、かなりポータビリティが高そう。

[Samsung The Premiere 5 Full HD Touch Interaction Projector (2025)](https://www.samsung.com/uk/projectors/the-premiere/lpf5-touch-interaction-projector-sp-lpf5dsaxxxu/)

持ち運びしやすいし、発色すごいし、使い方の幅広さがすごい。日本で発売するかどうかと、価格がどうなるかが気になるところ。。

---

## 2025-05-13: Barrel import / export のメリデメ

### Barrel import/exportとは何か

- index.tsで複数モジュールをまとめて再エクスポートする手法

### メリット

- import文が簡潔になる
- モジュールのエントリーポイントを統一できる
- リファクタやファイル構成変更時の影響範囲を減らせる

### デメリット

- 循環参照が発生しやすくなる
- 依存関係が増える
- 依存関係が不明瞭になりやすい
- 別で既にindex.tsが存在する場合の共存どうする問題がある
- ツリーシェイキングが効かなくなる場合がある
- コーディング時も考慮事項が増える

### まとめ・所感

- 正直いらないと思う
- eslint-plugin-no-barrel-filesを導入して、barrelファイルとなるindex.tsを禁止するのが良いかも

### 参考

- <https://typescript-jp.gitbook.io/deep-dive/main-1/barrel>
- <https://developers.prtimes.jp/2025/01/28/avoid-barrel-files-in-prtimes/>

---

## 2025-05-12: TanStack Query / SWRが導入されていないプロジェクトでのAPIリクエスト競合状態の回避法

TanStack QueryやSWRは、データフェッチライブラリではなく、非同期な状態管理ライブラリである。これらの"sane
defaults"により、APIなどの非同期状態のハンドリングがカバーされる。

ただし、未導入のプロジェクトでは、場当たり的なAPIリクエスト競合回避が必要になる場合がある。以下はReact
Router前提だが、Vanilla JSでも応用可能。

```ts
import { matchPath } from 'react-router';
import { z } from 'zod';
import { isValid, parse } from 'date-fns';

function isHttpError(response: Response): boolean {
  return !response.ok;
}

function handleHttpError(response: Response): void {
  console.error('HTTP error', response.status);
}

const yearMonthParamSchema = z.string().refine(
  val => {
    const parsedDate = parse(val, 'yyyy-MM', new Date());
    return isValid(parsedDate);
  },
  {
    message: 'Invalid yearMonth format',
  }
);

const getCurrentSelectedYearMonthParam = () => {
  const pathMatch = matchPath('page-name/:selectedYearMonth', window.location.pathname);
  if (!pathMatch) return;

  const result = yearMonthParamSchema.safeParse(pathMatch.params.selectedYearMonth);
  if (!result.success) return;

  return result.data;
};

export const fetchData = async (params: { yearMonth: string }) => {
  const response = await fetch(`/api/v1/collection?yearMonth=${params.yearMonth}`);

  if (isHttpError(response)) {
    handleHttpError(response);
    return;
  }

  const currentSelectedYearMonthParam = getCurrentSelectedYearMonthParam();
  if (typeof currentSelectedYearMonthParam === 'undefined' || currentSelectedYearMonthParam !== params.yearMonth) {
    // 競合状態を回避するために、APIリクエストの結果を無視する
    return;
  }

  const data = await response.json();

  return data;
};
```

- レースコンディション
- ウォーターフォール問題

などの根本解決にはならないが、場当たり的なAPIリクエスト競合回避としては十分に機能する。

---

## 2025-05-11: ClineをGitHub Copilot Proの有料プランで使う

### Clineとは

- オープンソースのAIエージェント。コード生成や質問応答が可能。
- カスタマイズ性が高く、様々なモデル・エディタ・プロンプト・カスタムフォークに対応。
- エクステンションなので、あらゆるエディタで利用可能（Cursor, Windsurf, Bolt.new等と異なる点）。

参考：

- <https://cline.bot/>
- <https://youtu.be/TFU33etuKb0?si=VYo2BY7UJXtd9hCI>

### できるだけ安価でAI agentを使うために

フリープランのAPI Provider: `OpenRouter` / Language Model: `claude-3.7-sonnet`のクレジットを使い切った。

既に[GitHub Copilot Pro](https://github.com/features/copilot) (年100ドル)を導入していたので、その範囲でClineを利用。

API Provider: `VS Code LM API` / Language Model: `copilot - gpt-4.1`にし、Plan
modeを選択すると通信量を抑えられ、安価に利用可能。

GitHub Copilot ProのAgent modeとも比較しながら使ってみる予定。

参考：

- <https://qiita.com/generokenken/items/ef761c49a8d23336642c>

---

## 2025-05-10: バージョン管理と時間管理

### バージョン管理

[asdf](https://asdf-vm.com/)から[mise](https://github.com/jdx/mise)へ乗り換え。Figmaの作者で、スポンサーも多く、プラグインの別管理が不要なのが利点。

mise有効化には、シェル初期化ファイルに以下を追加：

```sh
# See https://mise.jdx.dev/cli/activate.html
echo 'eval "$(mise activate zsh)"' >> ~/.zshrc
```

### 時間管理

脳の「実行機能」を働かせる4ステップ：

1. 「スタートする」
2. 「計画を立てる」
3. 「進捗をモニタリングする」
4. 「脱線を防止する」

参考：朝日新聞 be on Saturday 2025年5月10日号

---

## 2025-05-09: [Topic Title]

[Description of what you learned today]

### Example/Code (if applicable)

```txt
# Code example here
```

### References

- [Reference link 1](https://example.com)
- [Reference link 2](https://example.com)

---
