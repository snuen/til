# May 2025 TIL (Today I Learned)

This file contains things I learned during May 2025.

---

## 2025-05-16: Redux Style Guide

昔からRedux依存しているプロダクトに関わっていると、ついつい見逃しがちだが、[Redux Style Guide](https://redux.js.org/style-guide/)というのがある。

基本はunopinionatedだけど、ライブラリ開発側が「今までの開発経験上こうした方がよい」というのをまとめたスタイルガイドになっている。

ここに書かれたルールを手広く網羅したコードを以下に貼っておく。

Priority B Rule: Structure Files as Feature Folders with Single-File Logic

`src/features/todos/todos-slice.ts`:

```ts
// Priority A Rule: Do not mutate state directly (but Immer in createSlice makes this safe!)
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

/**
 * Selectors
 */

// Priority C Rule: Use Selector Functions to Read from Store State
// Priority C Rule: Name Selector Functions as selectThing
export const selectTodos = (state: RootState) => state.todos.items;
export const selectCompletedTodos = (state: RootState) => state.todos.items.filter(t => t.completed);

/**
 * Thunks
 */

// Priority C Rule: Use Thunks and Listeners for Other Async Logic
export const fetchTodos = createAsyncThunk<Todo[]>('todos/fetchTodos', async () => {
  const response = await fetch('/api/todos');
  return await response.json();
});

interface Todo {
  id: number;
  text: string;
  completed: boolean;
  createdAt: string;
}

interface TodosState {
  items: Todo[];
}

const initialState: TodosState = {
  items: [],
};

const todosSlice = createSlice({
  // Priority C Rule: Write Action Types as `domain/eventName`
  name: 'todos',
  initialState,
  reducers: {
    // Priority B Rule: Model Actions as Events, Not Setters
    // Actionはイベントとしてモデル化し、具体的な名前にする
    // Priority B Rule: Use Immer for Writing Immutable Updates
    // Immerにより「state.items.push」も安全
    // Priority B Rule: Put as Much Logic as Possible in Reducers
    // Reducerにロジックを集約する
    addTodo(state, action: PayloadAction<string>) {
      state.items.push({
        id: Date.now(),
        text: action.payload,
        completed: false,
        // Priority A Rule: Do Not Put Non-Serializable Values in State or Actions
        createdAt: new Date().toISOString(),
      });
    },
    // Priority B Rule: Treat Reducers as State Machines
    // Reducerは状態遷移を表すものとして扱う
    toggleTodo(state, action: PayloadAction<number>) {
      const todo = state.items.find(t => t.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    removeTodo(state, action: PayloadAction<number>) {
      state.items = state.items.filter(t => t.id !== action.payload);
    },
    addAndSelectTodo: {
      // Priority B Rule: Avoid Dispatching Many Actions Sequentially
      reducer(state, action: PayloadAction<{ id: string; text: string }>) {
        state.entities[action.payload.id] = {
          id: action.payload.id,
          text: action.payload.text,
          completed: false,
          listId: 'list-1',
        };
        state.ids.push(action.payload.id);
        state.selectedId = action.payload.id;
      },
      prepare(text: string) {
        return { payload: { id: crypto.randomUUID(), text } };
      },
    },
  },
  extraReducers: builder => {
    builder.addCase(fetchTodos.fulfilled, (state, action) => {
      state.items = action.payload;
    });
  },
});

export const { addTodo, toggleTodo, removeTodo } = todosSlice.actions;
export default todosSlice.reducer;
```

`src/features/todos/todo.tsx`:

```tsx
// Priority C Rule: Use the React-Redux Hooks API
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { selectTodos, addTodo, toggleTodo, removeTodo } from './todosSlice';

export const TodoList: React.FC = () => {
  const todos = useSelector(selectTodos);
  const dispatch = useDispatch();

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          <input type="checkbox" checked={todo.completed} onChange={() => dispatch(toggleTodo(todo.id))} />
          {todo.text}
          <button onClick={() => dispatch(removeTodo(todo.id))}>Delete</button>
        </li>
      ))}
    </ul>
  );
};
```

---

## 2025-05-15: どのリポジトリでも転用が効くと思うPRテンプレート

大体以下で必要十分なのではないかと思う。

```md
## 概要

<!-- 目的・背景 -->

## 内容

<!-- 主な修正点 -->

## 影響

<!-- 影響範囲や注意点 -->

## テスト

<!-- 動作確認やテスト内容 -->

## 関連

<!-- Issueや参考リンク等 -->
```

---

## 2025-05-14: 最近気になっているガジェット

[Tern Setups](https://ternsetups.com/)

モニタとスタンドが一体となっていて、かなりポータビリティが高そう。

[Samsung The Premiere 5 Full HD Touch Interaction Projector (2025)](https://www.samsung.com/uk/projectors/the-premiere/lpf5-touch-interaction-projector-sp-lpf5dsaxxxu/)

持ち運びしやすいし、発色すごいし、使い方の幅広さがすごい。日本で発売するかどうかと、価格がどうなるかが気になるところ。。

---

## 2025-05-13: Barrel import / export のメリデメ

### Barrel import/exportとは何か

- index.tsで複数モジュールをまとめて再エクスポートする手法

### メリット

- import文が簡潔になる
- モジュールのエントリーポイントを統一できる
- リファクタやファイル構成変更時の影響範囲を減らせる

### デメリット

- 循環参照が発生しやすくなる
- 依存関係が増える
- 依存関係が不明瞭になりやすい
- 別で既にindex.tsが存在する場合の共存どうする問題がある
- ツリーシェイキングが効かなくなる場合がある
- コーディング時も考慮事項が増える

### まとめ・所感

- 正直いらないと思う
- eslint-plugin-no-barrel-filesを導入して、barrelファイルとなるindex.tsを禁止するのが良いかも

### 参考

- <https://typescript-jp.gitbook.io/deep-dive/main-1/barrel>
- <https://developers.prtimes.jp/2025/01/28/avoid-barrel-files-in-prtimes/>

---

## 2025-05-12: TanStack Query / SWRが導入されていないプロジェクトでのAPIリクエスト競合状態の回避法

TanStack QueryやSWRは、データフェッチライブラリではなく、非同期な状態管理ライブラリである。これらの"sane
defaults"により、APIなどの非同期状態のハンドリングがカバーされる。

ただし、未導入のプロジェクトでは、場当たり的なAPIリクエスト競合回避が必要になる場合がある。以下はReact
Router前提だが、Vanilla JSでも応用可能。

```ts
import { matchPath } from 'react-router';
import { z } from 'zod';
import { isValid, parse } from 'date-fns';

const yearMonthParamSchema = z.string().refine(
  val => {
    const parsedDate = parse(val, 'yyyy-MM', new Date());
    return isValid(parsedDate);
  },
  {
    message: 'Invalid yearMonth format',
  }
);

// `/page-name/2025-05`のパス例
const getCurrentSelectedYearMonthParam = () => {
  const pathMatch = matchPath('page-name/:selectedYearMonth');
  if (!pathMatch) return;

  const result = yearMonthParamSchema.safeParse(pathMatch.params.selectedYearMonth);
  if (!result.success) return;

  return result.data;
};

export const fetchData = async (params: { yearMonth: string }) => {
  const response = await fetch(`/api/v1/collection?yearMonth=${params.yearMonth}`);

  if (isHttpError(response)) {
    handleHttpError(response);
    return;
  }

  const currentSelectedYearMonthParam = getCurrentSelectedYearMonthParam();
  if (typeof currentSelectedYearMonthParam === 'undefined' || currentSelectedYearMonthParam !== params.yearMonth) {
    // 競合状態を回避するために、APIリクエストの結果を無視する
    return;
  }

  const data = await response.json();

  return data;
};
```

- レースコンディション
- ウォーターフォール問題

などの根本解決にはならないが、場当たり的なAPIリクエスト競合回避としては十分に機能する。

---

## 2025-05-11: ClineをGitHub Copilot Proの有料プランで使う

### Clineとは

- オープンソースのAIエージェント。コード生成や質問応答が可能。
- カスタマイズ性が高く、様々なモデル・エディタ・プロンプト・カスタムフォークに対応。
- エクステンションなので、あらゆるエディタで利用可能（Cursor, Windsurf, Bolt.new等と異なる点）。

参考：

- <https://cline.bot/>
- <https://youtu.be/TFU33etuKb0?si=VYo2BY7UJXtd9hCI>

### できるだけ安価でAI agentを使うために

フリープランのAPI Provider: `OpenRouter` / Language Model: `claude-3.7-sonnet`のクレジットを使い切った。

既に[GitHub Copilot Pro](https://github.com/features/copilot) (年100ドル)を導入していたので、その範囲でClineを利用。

API Provider: `VS Code LM API` / Language Model: `copilot - gpt-4.1`にし、Plan
modeを選択すると通信量を抑えられ、安価に利用可能。

GitHub Copilot ProのAgent modeとも比較しながら使ってみる予定。

参考：

- <https://qiita.com/generokenken/items/ef761c49a8d23336642c>

---

## 2025-05-10: バージョン管理と時間管理

### バージョン管理

[asdf](https://asdf-vm.com/)から[mise](https://github.com/jdx/mise)へ乗り換え。Figmaの作者で、スポンサーも多く、プラグインの別管理が不要なのが利点。

mise有効化には、シェル初期化ファイルに以下を追加：

```sh
# See https://mise.jdx.dev/cli/activate.html
echo 'eval "$(mise activate zsh)"' >> ~/.zshrc
```

### 時間管理

脳の「実行機能」を働かせる4ステップ：

1. 「スタートする」
2. 「計画を立てる」
3. 「進捗をモニタリングする」
4. 「脱線を防止する」

参考：朝日新聞 be on Saturday 2025年5月10日号

---

## 2025-05-09: [Topic Title]

[Description of what you learned today]

### Example/Code (if applicable)

```txt
# Code example here
```

### References

- [Reference link 1](https://example.com)
- [Reference link 2](https://example.com)

---
